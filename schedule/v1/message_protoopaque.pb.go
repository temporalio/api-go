// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/schedule/v1/message.proto

//go:build protoopaque

package schedule

import (
	reflect "reflect"
	"strconv"
	unsafe "unsafe"

	v12 "go.temporal.io/api/common/v1"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/workflow/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CalendarSpec describes an event specification relative to the calendar,
// similar to a traditional cron specification, but with labeled fields. Each
// field can be one of:
//
//	*: matches always
//	x: matches when the field equals x
//	x/y : matches when the field equals x+n*y where n is an integer
//	x-z: matches when the field is between x and z inclusive
//	w,x,y,...: matches when the field is one of the listed values
//
// Each x, y, z, ... is either a decimal integer, or a month or day of week name
// or abbreviation (in the appropriate fields).
// A timestamp matches if all fields match.
// Note that fields have different default values, for convenience.
// Note that the special case that some cron implementations have for treating
// day_of_month and day_of_week as "or" instead of "and" when both are set is
// not implemented.
// day_of_week can accept 0 or 7 as Sunday
// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
// returned if you describe the schedule.
type CalendarSpec struct {
	state                 protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Second     string                 `protobuf:"bytes,1,opt,name=second,proto3"`
	xxx_hidden_Minute     string                 `protobuf:"bytes,2,opt,name=minute,proto3"`
	xxx_hidden_Hour       string                 `protobuf:"bytes,3,opt,name=hour,proto3"`
	xxx_hidden_DayOfMonth string                 `protobuf:"bytes,4,opt,name=day_of_month,json=dayOfMonth,proto3"`
	xxx_hidden_Month      string                 `protobuf:"bytes,5,opt,name=month,proto3"`
	xxx_hidden_Year       string                 `protobuf:"bytes,6,opt,name=year,proto3"`
	xxx_hidden_DayOfWeek  string                 `protobuf:"bytes,7,opt,name=day_of_week,json=dayOfWeek,proto3"`
	xxx_hidden_Comment    string                 `protobuf:"bytes,8,opt,name=comment,proto3"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *CalendarSpec) Reset() {
	*x = CalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CalendarSpec) ProtoMessage() {}

func (x *CalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CalendarSpec) GetSecond() string {
	if x != nil {
		return x.xxx_hidden_Second
	}
	return ""
}

func (x *CalendarSpec) GetMinute() string {
	if x != nil {
		return x.xxx_hidden_Minute
	}
	return ""
}

func (x *CalendarSpec) GetHour() string {
	if x != nil {
		return x.xxx_hidden_Hour
	}
	return ""
}

func (x *CalendarSpec) GetDayOfMonth() string {
	if x != nil {
		return x.xxx_hidden_DayOfMonth
	}
	return ""
}

func (x *CalendarSpec) GetMonth() string {
	if x != nil {
		return x.xxx_hidden_Month
	}
	return ""
}

func (x *CalendarSpec) GetYear() string {
	if x != nil {
		return x.xxx_hidden_Year
	}
	return ""
}

func (x *CalendarSpec) GetDayOfWeek() string {
	if x != nil {
		return x.xxx_hidden_DayOfWeek
	}
	return ""
}

func (x *CalendarSpec) GetComment() string {
	if x != nil {
		return x.xxx_hidden_Comment
	}
	return ""
}

func (x *CalendarSpec) SetSecond(v string) {
	x.xxx_hidden_Second = v
}

func (x *CalendarSpec) SetMinute(v string) {
	x.xxx_hidden_Minute = v
}

func (x *CalendarSpec) SetHour(v string) {
	x.xxx_hidden_Hour = v
}

func (x *CalendarSpec) SetDayOfMonth(v string) {
	x.xxx_hidden_DayOfMonth = v
}

func (x *CalendarSpec) SetMonth(v string) {
	x.xxx_hidden_Month = v
}

func (x *CalendarSpec) SetYear(v string) {
	x.xxx_hidden_Year = v
}

func (x *CalendarSpec) SetDayOfWeek(v string) {
	x.xxx_hidden_DayOfWeek = v
}

func (x *CalendarSpec) SetComment(v string) {
	x.xxx_hidden_Comment = v
}

type CalendarSpec_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Expression to match seconds. Default: 0
	Second string
	// Expression to match minutes. Default: 0
	Minute string
	// Expression to match hours. Default: 0
	Hour string
	// Expression to match days of the month. Default: *
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth string
	// Expression to match months. Default: *
	Month string
	// Expression to match years. Default: *
	Year string
	// Expression to match days of the week. Default: *
	DayOfWeek string
	// Free-form comment describing the intention of this spec.
	Comment string
}

func (b0 CalendarSpec_builder) Build() *CalendarSpec {
	m0 := &CalendarSpec{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Second = b.Second
	x.xxx_hidden_Minute = b.Minute
	x.xxx_hidden_Hour = b.Hour
	x.xxx_hidden_DayOfMonth = b.DayOfMonth
	x.xxx_hidden_Month = b.Month
	x.xxx_hidden_Year = b.Year
	x.xxx_hidden_DayOfWeek = b.DayOfWeek
	x.xxx_hidden_Comment = b.Comment
	return m0
}

// Range represents a set of integer values, used to match fields of a calendar
// time in StructuredCalendarSpec. If end < start, then end is interpreted as
// equal to start. This means you can use a Range with start set to a value, and
// end and step unset (defaulting to 0) to represent a single value.
type Range struct {
	state            protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Start int32                  `protobuf:"varint,1,opt,name=start,proto3"`
	xxx_hidden_End   int32                  `protobuf:"varint,2,opt,name=end,proto3"`
	xxx_hidden_Step  int32                  `protobuf:"varint,3,opt,name=step,proto3"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Range) Reset() {
	*x = Range{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Range) GetStart() int32 {
	if x != nil {
		return x.xxx_hidden_Start
	}
	return 0
}

func (x *Range) GetEnd() int32 {
	if x != nil {
		return x.xxx_hidden_End
	}
	return 0
}

func (x *Range) GetStep() int32 {
	if x != nil {
		return x.xxx_hidden_Step
	}
	return 0
}

func (x *Range) SetStart(v int32) {
	x.xxx_hidden_Start = v
}

func (x *Range) SetEnd(v int32) {
	x.xxx_hidden_End = v
}

func (x *Range) SetStep(v int32) {
	x.xxx_hidden_Step = v
}

type Range_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Start of range (inclusive).
	Start int32
	// End of range (inclusive).
	End int32
	// Step (optional, default 1).
	Step int32
}

func (b0 Range_builder) Build() *Range {
	m0 := &Range{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Start = b.Start
	x.xxx_hidden_End = b.End
	x.xxx_hidden_Step = b.Step
	return m0
}

// StructuredCalendarSpec describes an event specification relative to the
// calendar, in a form that's easy to work with programmatically. Each field can
// be one or more ranges.
// A timestamp matches if at least one range of each field matches the
// corresponding fields of the timestamp, except for year: if year is missing,
// that means all years match. For all fields besides year, at least one Range
// must be present to match anything.
// Relative expressions such as "last day of the month" or "third Monday" are not currently
// representable; callers must enumerate the concrete days they require.
type StructuredCalendarSpec struct {
	state                 protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Second     *[]*Range              `protobuf:"bytes,1,rep,name=second,proto3"`
	xxx_hidden_Minute     *[]*Range              `protobuf:"bytes,2,rep,name=minute,proto3"`
	xxx_hidden_Hour       *[]*Range              `protobuf:"bytes,3,rep,name=hour,proto3"`
	xxx_hidden_DayOfMonth *[]*Range              `protobuf:"bytes,4,rep,name=day_of_month,json=dayOfMonth,proto3"`
	xxx_hidden_Month      *[]*Range              `protobuf:"bytes,5,rep,name=month,proto3"`
	xxx_hidden_Year       *[]*Range              `protobuf:"bytes,6,rep,name=year,proto3"`
	xxx_hidden_DayOfWeek  *[]*Range              `protobuf:"bytes,7,rep,name=day_of_week,json=dayOfWeek,proto3"`
	xxx_hidden_Comment    string                 `protobuf:"bytes,8,opt,name=comment,proto3"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *StructuredCalendarSpec) Reset() {
	*x = StructuredCalendarSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StructuredCalendarSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StructuredCalendarSpec) ProtoMessage() {}

func (x *StructuredCalendarSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *StructuredCalendarSpec) GetSecond() []*Range {
	if x != nil {
		if x.xxx_hidden_Second != nil {
			return *x.xxx_hidden_Second
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMinute() []*Range {
	if x != nil {
		if x.xxx_hidden_Minute != nil {
			return *x.xxx_hidden_Minute
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetHour() []*Range {
	if x != nil {
		if x.xxx_hidden_Hour != nil {
			return *x.xxx_hidden_Hour
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfMonth() []*Range {
	if x != nil {
		if x.xxx_hidden_DayOfMonth != nil {
			return *x.xxx_hidden_DayOfMonth
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetMonth() []*Range {
	if x != nil {
		if x.xxx_hidden_Month != nil {
			return *x.xxx_hidden_Month
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetYear() []*Range {
	if x != nil {
		if x.xxx_hidden_Year != nil {
			return *x.xxx_hidden_Year
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetDayOfWeek() []*Range {
	if x != nil {
		if x.xxx_hidden_DayOfWeek != nil {
			return *x.xxx_hidden_DayOfWeek
		}
	}
	return nil
}

func (x *StructuredCalendarSpec) GetComment() string {
	if x != nil {
		return x.xxx_hidden_Comment
	}
	return ""
}

func (x *StructuredCalendarSpec) SetSecond(v []*Range) {
	x.xxx_hidden_Second = &v
}

func (x *StructuredCalendarSpec) SetMinute(v []*Range) {
	x.xxx_hidden_Minute = &v
}

func (x *StructuredCalendarSpec) SetHour(v []*Range) {
	x.xxx_hidden_Hour = &v
}

func (x *StructuredCalendarSpec) SetDayOfMonth(v []*Range) {
	x.xxx_hidden_DayOfMonth = &v
}

func (x *StructuredCalendarSpec) SetMonth(v []*Range) {
	x.xxx_hidden_Month = &v
}

func (x *StructuredCalendarSpec) SetYear(v []*Range) {
	x.xxx_hidden_Year = &v
}

func (x *StructuredCalendarSpec) SetDayOfWeek(v []*Range) {
	x.xxx_hidden_DayOfWeek = &v
}

func (x *StructuredCalendarSpec) SetComment(v string) {
	x.xxx_hidden_Comment = v
}

type StructuredCalendarSpec_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Match seconds (0-59)
	Second []*Range
	// Match minutes (0-59)
	Minute []*Range
	// Match hours (0-23)
	Hour []*Range
	// Match days of the month (1-31)
	// (-- api-linter: core::0140::prepositions=disabled
	//
	//	aip.dev/not-precedent: standard name of field --)
	DayOfMonth []*Range
	// Match months (1-12)
	Month []*Range
	// Match years.
	Year []*Range
	// Match days of the week (0-6; 0 is Sunday).
	DayOfWeek []*Range
	// Free-form comment describing the intention of this spec.
	Comment string
}

func (b0 StructuredCalendarSpec_builder) Build() *StructuredCalendarSpec {
	m0 := &StructuredCalendarSpec{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Second = &b.Second
	x.xxx_hidden_Minute = &b.Minute
	x.xxx_hidden_Hour = &b.Hour
	x.xxx_hidden_DayOfMonth = &b.DayOfMonth
	x.xxx_hidden_Month = &b.Month
	x.xxx_hidden_Year = &b.Year
	x.xxx_hidden_DayOfWeek = &b.DayOfWeek
	x.xxx_hidden_Comment = b.Comment
	return m0
}

// IntervalSpec matches times that can be expressed as:
// epoch + n * interval + phase
// where n is an integer.
// phase defaults to zero if missing. interval is required.
// Both interval and phase must be non-negative and are truncated to the nearest
// second before any calculations.
// For example, an interval of 1 hour with phase of zero would match every hour,
// on the hour. The same interval but a phase of 19 minutes would match every
// xx:19:00. An interval of 28 days with phase zero would match
// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
type IntervalSpec struct {
	state               protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Interval *durationpb.Duration   `protobuf:"bytes,1,opt,name=interval,proto3"`
	xxx_hidden_Phase    *durationpb.Duration   `protobuf:"bytes,2,opt,name=phase,proto3"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *IntervalSpec) Reset() {
	*x = IntervalSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntervalSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalSpec) ProtoMessage() {}

func (x *IntervalSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *IntervalSpec) GetInterval() *durationpb.Duration {
	if x != nil {
		return x.xxx_hidden_Interval
	}
	return nil
}

func (x *IntervalSpec) GetPhase() *durationpb.Duration {
	if x != nil {
		return x.xxx_hidden_Phase
	}
	return nil
}

func (x *IntervalSpec) SetInterval(v *durationpb.Duration) {
	x.xxx_hidden_Interval = v
}

func (x *IntervalSpec) SetPhase(v *durationpb.Duration) {
	x.xxx_hidden_Phase = v
}

func (x *IntervalSpec) HasInterval() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Interval != nil
}

func (x *IntervalSpec) HasPhase() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Phase != nil
}

func (x *IntervalSpec) ClearInterval() {
	x.xxx_hidden_Interval = nil
}

func (x *IntervalSpec) ClearPhase() {
	x.xxx_hidden_Phase = nil
}

type IntervalSpec_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Interval *durationpb.Duration
	Phase    *durationpb.Duration
}

func (b0 IntervalSpec_builder) Build() *IntervalSpec {
	m0 := &IntervalSpec{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Interval = b.Interval
	x.xxx_hidden_Phase = b.Phase
	return m0
}

// ScheduleSpec is a complete description of a set of absolute timestamps
// (possibly infinite) that an action should occur at. The meaning of a
// ScheduleSpec depends only on its contents and never changes, except that the
// definition of a time zone can change over time (most commonly, when daylight
// saving time policy changes for an area). To create a totally self-contained
// ScheduleSpec, use UTC or include timezone_data.
//
// For input, you can provide zero or more of: structured_calendar, calendar,
// cron_string, interval, and exclude_structured_calendar, and all of them will
// be used (the schedule will take action at the union of all of their times,
// minus the ones that match exclude_structured_calendar).
//
// On input, calendar and cron_string fields will be compiled into
// structured_calendar (and maybe interval and timezone_name), so if you
// Describe a schedule, you'll see only structured_calendar, interval, etc.
//
// If a spec has no matching times after the current time, then the schedule
// will be subject to automatic deletion (after several days).
type ScheduleSpec struct {
	state                                protoimpl.MessageState     `protogen:"opaque.v1"`
	xxx_hidden_StructuredCalendar        *[]*StructuredCalendarSpec `protobuf:"bytes,7,rep,name=structured_calendar,json=structuredCalendar,proto3"`
	xxx_hidden_CronString                []string                   `protobuf:"bytes,8,rep,name=cron_string,json=cronString,proto3"`
	xxx_hidden_Calendar                  *[]*CalendarSpec           `protobuf:"bytes,1,rep,name=calendar,proto3"`
	xxx_hidden_Interval                  *[]*IntervalSpec           `protobuf:"bytes,2,rep,name=interval,proto3"`
	xxx_hidden_ExcludeCalendar           *[]*CalendarSpec           `protobuf:"bytes,3,rep,name=exclude_calendar,json=excludeCalendar,proto3"`
	xxx_hidden_ExcludeStructuredCalendar *[]*StructuredCalendarSpec `protobuf:"bytes,9,rep,name=exclude_structured_calendar,json=excludeStructuredCalendar,proto3"`
	xxx_hidden_StartTime                 *timestamppb.Timestamp     `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3"`
	xxx_hidden_EndTime                   *timestamppb.Timestamp     `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3"`
	xxx_hidden_Jitter                    *durationpb.Duration       `protobuf:"bytes,6,opt,name=jitter,proto3"`
	xxx_hidden_TimezoneName              string                     `protobuf:"bytes,10,opt,name=timezone_name,json=timezoneName,proto3"`
	xxx_hidden_TimezoneData              []byte                     `protobuf:"bytes,11,opt,name=timezone_data,json=timezoneData,proto3"`
	unknownFields                        protoimpl.UnknownFields
	sizeCache                            protoimpl.SizeCache
}

func (x *ScheduleSpec) Reset() {
	*x = ScheduleSpec{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleSpec) ProtoMessage() {}

func (x *ScheduleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleSpec) GetStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		if x.xxx_hidden_StructuredCalendar != nil {
			return *x.xxx_hidden_StructuredCalendar
		}
	}
	return nil
}

func (x *ScheduleSpec) GetCronString() []string {
	if x != nil {
		return x.xxx_hidden_CronString
	}
	return nil
}

func (x *ScheduleSpec) GetCalendar() []*CalendarSpec {
	if x != nil {
		if x.xxx_hidden_Calendar != nil {
			return *x.xxx_hidden_Calendar
		}
	}
	return nil
}

func (x *ScheduleSpec) GetInterval() []*IntervalSpec {
	if x != nil {
		if x.xxx_hidden_Interval != nil {
			return *x.xxx_hidden_Interval
		}
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleSpec) GetExcludeCalendar() []*CalendarSpec {
	if x != nil {
		if x.xxx_hidden_ExcludeCalendar != nil {
			return *x.xxx_hidden_ExcludeCalendar
		}
	}
	return nil
}

func (x *ScheduleSpec) GetExcludeStructuredCalendar() []*StructuredCalendarSpec {
	if x != nil {
		if x.xxx_hidden_ExcludeStructuredCalendar != nil {
			return *x.xxx_hidden_ExcludeStructuredCalendar
		}
	}
	return nil
}

func (x *ScheduleSpec) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_StartTime
	}
	return nil
}

func (x *ScheduleSpec) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_EndTime
	}
	return nil
}

func (x *ScheduleSpec) GetJitter() *durationpb.Duration {
	if x != nil {
		return x.xxx_hidden_Jitter
	}
	return nil
}

func (x *ScheduleSpec) GetTimezoneName() string {
	if x != nil {
		return x.xxx_hidden_TimezoneName
	}
	return ""
}

func (x *ScheduleSpec) GetTimezoneData() []byte {
	if x != nil {
		return x.xxx_hidden_TimezoneData
	}
	return nil
}

func (x *ScheduleSpec) SetStructuredCalendar(v []*StructuredCalendarSpec) {
	x.xxx_hidden_StructuredCalendar = &v
}

func (x *ScheduleSpec) SetCronString(v []string) {
	x.xxx_hidden_CronString = v
}

func (x *ScheduleSpec) SetCalendar(v []*CalendarSpec) {
	x.xxx_hidden_Calendar = &v
}

func (x *ScheduleSpec) SetInterval(v []*IntervalSpec) {
	x.xxx_hidden_Interval = &v
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleSpec) SetExcludeCalendar(v []*CalendarSpec) {
	x.xxx_hidden_ExcludeCalendar = &v
}

func (x *ScheduleSpec) SetExcludeStructuredCalendar(v []*StructuredCalendarSpec) {
	x.xxx_hidden_ExcludeStructuredCalendar = &v
}

func (x *ScheduleSpec) SetStartTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_StartTime = v
}

func (x *ScheduleSpec) SetEndTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_EndTime = v
}

func (x *ScheduleSpec) SetJitter(v *durationpb.Duration) {
	x.xxx_hidden_Jitter = v
}

func (x *ScheduleSpec) SetTimezoneName(v string) {
	x.xxx_hidden_TimezoneName = v
}

func (x *ScheduleSpec) SetTimezoneData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_TimezoneData = v
}

func (x *ScheduleSpec) HasStartTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_StartTime != nil
}

func (x *ScheduleSpec) HasEndTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_EndTime != nil
}

func (x *ScheduleSpec) HasJitter() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Jitter != nil
}

func (x *ScheduleSpec) ClearStartTime() {
	x.xxx_hidden_StartTime = nil
}

func (x *ScheduleSpec) ClearEndTime() {
	x.xxx_hidden_EndTime = nil
}

func (x *ScheduleSpec) ClearJitter() {
	x.xxx_hidden_Jitter = nil
}

type ScheduleSpec_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Calendar-based specifications of times.
	StructuredCalendar []*StructuredCalendarSpec
	// cron_string holds a traditional cron specification as a string. It
	// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
	// same way as CalendarSpec.
	// 5 fields:         minute, hour, day_of_month, month, day_of_week
	// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
	// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
	// If year is not given, it defaults to *. If second is not given, it
	// defaults to 0.
	// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
	// accepted instead of the 5-7 time fields.
	// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
	// TZ=<timezone name>, which will get copied to timezone_name. (There must
	// not also be a timezone_name present.)
	// Optionally "#" followed by a comment can appear at the end of the string.
	// Note that the special case that some cron implementations have for
	// treating day_of_month and day_of_week as "or" instead of "and" when both
	// are set is not implemented.
	// @every <interval>[/<phase>] is accepted and gets compiled into an
	// IntervalSpec instead. <interval> and <phase> should be a decimal integer
	// with a unit suffix s, m, h, or d.
	CronString []string
	// Calendar-based specifications of times.
	Calendar []*CalendarSpec
	// Interval-based specifications of times.
	Interval []*IntervalSpec
	// Any timestamps matching any of exclude_* will be skipped.
	// Deprecated. Use exclude_structured_calendar.
	//
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	ExcludeCalendar           []*CalendarSpec
	ExcludeStructuredCalendar []*StructuredCalendarSpec
	// If start_time is set, any timestamps before start_time will be skipped.
	// (Together, start_time and end_time make an inclusive interval.)
	StartTime *timestamppb.Timestamp
	// If end_time is set, any timestamps after end_time will be skipped.
	EndTime *timestamppb.Timestamp
	// All timestamps will be incremented by a random value from 0 to this
	// amount of jitter. Default: 0
	Jitter *durationpb.Duration
	// Time zone to interpret all calendar-based specs in.
	//
	// If unset, defaults to UTC. We recommend using UTC for your application if
	// at all possible, to avoid various surprising properties of time zones.
	//
	// Time zones may be provided by name, corresponding to names in the IANA
	// time zone database (see https://www.iana.org/time-zones). The definition
	// will be loaded by the Temporal server from the environment it runs in.
	//
	// If your application requires more control over the time zone definition
	// used, it may pass in a complete definition in the form of a TZif file
	// from the time zone database. If present, this will be used instead of
	// loading anything from the environment. You are then responsible for
	// updating timezone_data when the definition changes.
	//
	// Calendar spec matching is based on literal matching of the clock time
	// with no special handling of DST: if you write a calendar spec that fires
	// at 2:30am and specify a time zone that follows DST, that action will not
	// be triggered on the day that has no 2:30am. Similarly, an action that
	// fires at 1:30am will be triggered twice on the day that has two 1:30s.
	//
	// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
	TimezoneName string
	TimezoneData []byte
}

func (b0 ScheduleSpec_builder) Build() *ScheduleSpec {
	m0 := &ScheduleSpec{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_StructuredCalendar = &b.StructuredCalendar
	x.xxx_hidden_CronString = b.CronString
	x.xxx_hidden_Calendar = &b.Calendar
	x.xxx_hidden_Interval = &b.Interval
	x.xxx_hidden_ExcludeCalendar = &b.ExcludeCalendar
	x.xxx_hidden_ExcludeStructuredCalendar = &b.ExcludeStructuredCalendar
	x.xxx_hidden_StartTime = b.StartTime
	x.xxx_hidden_EndTime = b.EndTime
	x.xxx_hidden_Jitter = b.Jitter
	x.xxx_hidden_TimezoneName = b.TimezoneName
	x.xxx_hidden_TimezoneData = b.TimezoneData
	return m0
}

type SchedulePolicies struct {
	state                             protoimpl.MessageState   `protogen:"opaque.v1"`
	xxx_hidden_OverlapPolicy          v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy"`
	xxx_hidden_CatchupWindow          *durationpb.Duration     `protobuf:"bytes,2,opt,name=catchup_window,json=catchupWindow,proto3"`
	xxx_hidden_PauseOnFailure         bool                     `protobuf:"varint,3,opt,name=pause_on_failure,json=pauseOnFailure,proto3"`
	xxx_hidden_KeepOriginalWorkflowId bool                     `protobuf:"varint,4,opt,name=keep_original_workflow_id,json=keepOriginalWorkflowId,proto3"`
	unknownFields                     protoimpl.UnknownFields
	sizeCache                         protoimpl.SizeCache
}

func (x *SchedulePolicies) Reset() {
	*x = SchedulePolicies{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePolicies) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePolicies) ProtoMessage() {}

func (x *SchedulePolicies) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SchedulePolicies) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.xxx_hidden_OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *SchedulePolicies) GetCatchupWindow() *durationpb.Duration {
	if x != nil {
		return x.xxx_hidden_CatchupWindow
	}
	return nil
}

func (x *SchedulePolicies) GetPauseOnFailure() bool {
	if x != nil {
		return x.xxx_hidden_PauseOnFailure
	}
	return false
}

func (x *SchedulePolicies) GetKeepOriginalWorkflowId() bool {
	if x != nil {
		return x.xxx_hidden_KeepOriginalWorkflowId
	}
	return false
}

func (x *SchedulePolicies) SetOverlapPolicy(v v1.ScheduleOverlapPolicy) {
	x.xxx_hidden_OverlapPolicy = v
}

func (x *SchedulePolicies) SetCatchupWindow(v *durationpb.Duration) {
	x.xxx_hidden_CatchupWindow = v
}

func (x *SchedulePolicies) SetPauseOnFailure(v bool) {
	x.xxx_hidden_PauseOnFailure = v
}

func (x *SchedulePolicies) SetKeepOriginalWorkflowId(v bool) {
	x.xxx_hidden_KeepOriginalWorkflowId = v
}

func (x *SchedulePolicies) HasCatchupWindow() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_CatchupWindow != nil
}

func (x *SchedulePolicies) ClearCatchupWindow() {
	x.xxx_hidden_CatchupWindow = nil
}

type SchedulePolicies_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Policy for overlaps.
	// Note that this can be changed after a schedule has taken some actions,
	// and some changes might produce unintuitive results. In general, the later
	// policy overrides the earlier policy.
	OverlapPolicy v1.ScheduleOverlapPolicy
	// Policy for catchups:
	// If the Temporal server misses an action due to one or more components
	// being down, and comes back up, the action will be run if the scheduled
	// time is within this window from the current time.
	// This value defaults to one year, and can't be less than 10 seconds.
	CatchupWindow *durationpb.Duration
	// If true, and a workflow run fails or times out, turn on "paused".
	// This applies after retry policies: the full chain of retries must fail to
	// trigger a pause here.
	PauseOnFailure bool
	// If true, and the action would start a workflow, a timestamp will not be
	// appended to the scheduled workflow id.
	KeepOriginalWorkflowId bool
}

func (b0 SchedulePolicies_builder) Build() *SchedulePolicies {
	m0 := &SchedulePolicies{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_OverlapPolicy = b.OverlapPolicy
	x.xxx_hidden_CatchupWindow = b.CatchupWindow
	x.xxx_hidden_PauseOnFailure = b.PauseOnFailure
	x.xxx_hidden_KeepOriginalWorkflowId = b.KeepOriginalWorkflowId
	return m0
}

type ScheduleAction struct {
	state             protoimpl.MessageState  `protogen:"opaque.v1"`
	xxx_hidden_Action isScheduleAction_Action `protobuf_oneof:"action"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ScheduleAction) Reset() {
	*x = ScheduleAction{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleAction) ProtoMessage() {}

func (x *ScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleAction) GetStartWorkflow() *v11.NewWorkflowExecutionInfo {
	if x != nil {
		if x, ok := x.xxx_hidden_Action.(*scheduleAction_StartWorkflow); ok {
			return x.StartWorkflow
		}
	}
	return nil
}

func (x *ScheduleAction) SetStartWorkflow(v *v11.NewWorkflowExecutionInfo) {
	if v == nil {
		x.xxx_hidden_Action = nil
		return
	}
	x.xxx_hidden_Action = &scheduleAction_StartWorkflow{v}
}

func (x *ScheduleAction) HasAction() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Action != nil
}

func (x *ScheduleAction) HasStartWorkflow() bool {
	if x == nil {
		return false
	}
	_, ok := x.xxx_hidden_Action.(*scheduleAction_StartWorkflow)
	return ok
}

func (x *ScheduleAction) ClearAction() {
	x.xxx_hidden_Action = nil
}

func (x *ScheduleAction) ClearStartWorkflow() {
	if _, ok := x.xxx_hidden_Action.(*scheduleAction_StartWorkflow); ok {
		x.xxx_hidden_Action = nil
	}
}

const ScheduleAction_Action_not_set_case case_ScheduleAction_Action = 0
const ScheduleAction_StartWorkflow_case case_ScheduleAction_Action = 1

func (x *ScheduleAction) WhichAction() case_ScheduleAction_Action {
	if x == nil {
		return ScheduleAction_Action_not_set_case
	}
	switch x.xxx_hidden_Action.(type) {
	case *scheduleAction_StartWorkflow:
		return ScheduleAction_StartWorkflow_case
	default:
		return ScheduleAction_Action_not_set_case
	}
}

type ScheduleAction_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Fields of oneof xxx_hidden_Action:
	// All fields of NewWorkflowExecutionInfo are valid except for:
	// - workflow_id_reuse_policy
	// - cron_schedule
	// The workflow id of the started workflow may not match this exactly,
	// it may have a timestamp appended for uniqueness.
	StartWorkflow *v11.NewWorkflowExecutionInfo
	// -- end of xxx_hidden_Action
}

func (b0 ScheduleAction_builder) Build() *ScheduleAction {
	m0 := &ScheduleAction{}
	b, x := &b0, m0
	_, _ = b, x
	if b.StartWorkflow != nil {
		x.xxx_hidden_Action = &scheduleAction_StartWorkflow{b.StartWorkflow}
	}
	return m0
}

type case_ScheduleAction_Action protoreflect.FieldNumber

func (x case_ScheduleAction_Action) String() string {
	switch x {
	case ScheduleAction_Action_not_set_case:
		return "ScheduleActionActionNotSetCase"
	case ScheduleAction_StartWorkflow_case:
		return "ScheduleActionStartWorkflowCase"
	default:
		return strconv.Itoa(int(x))
	}

}

type isScheduleAction_Action interface {
	isScheduleAction_Action()
}

type scheduleAction_StartWorkflow struct {
	// All fields of NewWorkflowExecutionInfo are valid except for:
	// - workflow_id_reuse_policy
	// - cron_schedule
	// The workflow id of the started workflow may not match this exactly,
	// it may have a timestamp appended for uniqueness.
	StartWorkflow *v11.NewWorkflowExecutionInfo `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3,oneof"`
}

func (*scheduleAction_StartWorkflow) isScheduleAction_Action() {}

type ScheduleActionResult struct {
	state                          protoimpl.MessageState     `protogen:"opaque.v1"`
	xxx_hidden_ScheduleTime        *timestamppb.Timestamp     `protobuf:"bytes,1,opt,name=schedule_time,json=scheduleTime,proto3"`
	xxx_hidden_ActualTime          *timestamppb.Timestamp     `protobuf:"bytes,2,opt,name=actual_time,json=actualTime,proto3"`
	xxx_hidden_StartWorkflowResult *v12.WorkflowExecution     `protobuf:"bytes,11,opt,name=start_workflow_result,json=startWorkflowResult,proto3"`
	xxx_hidden_StartWorkflowStatus v1.WorkflowExecutionStatus `protobuf:"varint,12,opt,name=start_workflow_status,json=startWorkflowStatus,proto3,enum=temporal.api.enums.v1.WorkflowExecutionStatus"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *ScheduleActionResult) Reset() {
	*x = ScheduleActionResult{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleActionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleActionResult) ProtoMessage() {}

func (x *ScheduleActionResult) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleActionResult) GetScheduleTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_ScheduleTime
	}
	return nil
}

func (x *ScheduleActionResult) GetActualTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_ActualTime
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowResult() *v12.WorkflowExecution {
	if x != nil {
		return x.xxx_hidden_StartWorkflowResult
	}
	return nil
}

func (x *ScheduleActionResult) GetStartWorkflowStatus() v1.WorkflowExecutionStatus {
	if x != nil {
		return x.xxx_hidden_StartWorkflowStatus
	}
	return v1.WorkflowExecutionStatus(0)
}

func (x *ScheduleActionResult) SetScheduleTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_ScheduleTime = v
}

func (x *ScheduleActionResult) SetActualTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_ActualTime = v
}

func (x *ScheduleActionResult) SetStartWorkflowResult(v *v12.WorkflowExecution) {
	x.xxx_hidden_StartWorkflowResult = v
}

func (x *ScheduleActionResult) SetStartWorkflowStatus(v v1.WorkflowExecutionStatus) {
	x.xxx_hidden_StartWorkflowStatus = v
}

func (x *ScheduleActionResult) HasScheduleTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ScheduleTime != nil
}

func (x *ScheduleActionResult) HasActualTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ActualTime != nil
}

func (x *ScheduleActionResult) HasStartWorkflowResult() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_StartWorkflowResult != nil
}

func (x *ScheduleActionResult) ClearScheduleTime() {
	x.xxx_hidden_ScheduleTime = nil
}

func (x *ScheduleActionResult) ClearActualTime() {
	x.xxx_hidden_ActualTime = nil
}

func (x *ScheduleActionResult) ClearStartWorkflowResult() {
	x.xxx_hidden_StartWorkflowResult = nil
}

type ScheduleActionResult_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Time that the action was taken (according to the schedule, including jitter).
	ScheduleTime *timestamppb.Timestamp
	// Time that the action was taken (real time).
	ActualTime *timestamppb.Timestamp
	// If action was start_workflow:
	StartWorkflowResult *v12.WorkflowExecution
	// If the action was start_workflow, this field will reflect an
	// eventually-consistent view of the started workflow's status.
	StartWorkflowStatus v1.WorkflowExecutionStatus
}

func (b0 ScheduleActionResult_builder) Build() *ScheduleActionResult {
	m0 := &ScheduleActionResult{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_ScheduleTime = b.ScheduleTime
	x.xxx_hidden_ActualTime = b.ActualTime
	x.xxx_hidden_StartWorkflowResult = b.StartWorkflowResult
	x.xxx_hidden_StartWorkflowStatus = b.StartWorkflowStatus
	return m0
}

type ScheduleState struct {
	state                       protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Notes            string                 `protobuf:"bytes,1,opt,name=notes,proto3"`
	xxx_hidden_Paused           bool                   `protobuf:"varint,2,opt,name=paused,proto3"`
	xxx_hidden_LimitedActions   bool                   `protobuf:"varint,3,opt,name=limited_actions,json=limitedActions,proto3"`
	xxx_hidden_RemainingActions int64                  `protobuf:"varint,4,opt,name=remaining_actions,json=remainingActions,proto3"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *ScheduleState) Reset() {
	*x = ScheduleState{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleState) ProtoMessage() {}

func (x *ScheduleState) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleState) GetNotes() string {
	if x != nil {
		return x.xxx_hidden_Notes
	}
	return ""
}

func (x *ScheduleState) GetPaused() bool {
	if x != nil {
		return x.xxx_hidden_Paused
	}
	return false
}

func (x *ScheduleState) GetLimitedActions() bool {
	if x != nil {
		return x.xxx_hidden_LimitedActions
	}
	return false
}

func (x *ScheduleState) GetRemainingActions() int64 {
	if x != nil {
		return x.xxx_hidden_RemainingActions
	}
	return 0
}

func (x *ScheduleState) SetNotes(v string) {
	x.xxx_hidden_Notes = v
}

func (x *ScheduleState) SetPaused(v bool) {
	x.xxx_hidden_Paused = v
}

func (x *ScheduleState) SetLimitedActions(v bool) {
	x.xxx_hidden_LimitedActions = v
}

func (x *ScheduleState) SetRemainingActions(v int64) {
	x.xxx_hidden_RemainingActions = v
}

type ScheduleState_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Informative human-readable message with contextual notes, e.g. the reason
	// a schedule is paused. The system may overwrite this message on certain
	// conditions, e.g. when pause-on-failure happens.
	Notes string
	// If true, do not take any actions based on the schedule spec.
	Paused bool
	// If limited_actions is true, decrement remaining_actions after each
	// action, and do not take any more scheduled actions if remaining_actions
	// is zero. Actions may still be taken by explicit request (i.e. trigger
	// immediately or backfill). Skipped actions (due to overlap policy) do not
	// count against remaining actions.
	// If a schedule has no more remaining actions, then the schedule will be
	// subject to automatic deletion (after several days).
	LimitedActions   bool
	RemainingActions int64
}

func (b0 ScheduleState_builder) Build() *ScheduleState {
	m0 := &ScheduleState{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Notes = b.Notes
	x.xxx_hidden_Paused = b.Paused
	x.xxx_hidden_LimitedActions = b.LimitedActions
	x.xxx_hidden_RemainingActions = b.RemainingActions
	return m0
}

type TriggerImmediatelyRequest struct {
	state                    protoimpl.MessageState   `protogen:"opaque.v1"`
	xxx_hidden_OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy"`
	xxx_hidden_ScheduledTime *timestamppb.Timestamp   `protobuf:"bytes,2,opt,name=scheduled_time,json=scheduledTime,proto3"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TriggerImmediatelyRequest) Reset() {
	*x = TriggerImmediatelyRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TriggerImmediatelyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TriggerImmediatelyRequest) ProtoMessage() {}

func (x *TriggerImmediatelyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TriggerImmediatelyRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.xxx_hidden_OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *TriggerImmediatelyRequest) GetScheduledTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_ScheduledTime
	}
	return nil
}

func (x *TriggerImmediatelyRequest) SetOverlapPolicy(v v1.ScheduleOverlapPolicy) {
	x.xxx_hidden_OverlapPolicy = v
}

func (x *TriggerImmediatelyRequest) SetScheduledTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_ScheduledTime = v
}

func (x *TriggerImmediatelyRequest) HasScheduledTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_ScheduledTime != nil
}

func (x *TriggerImmediatelyRequest) ClearScheduledTime() {
	x.xxx_hidden_ScheduledTime = nil
}

type TriggerImmediatelyRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// If set, override overlap policy for this one request.
	OverlapPolicy v1.ScheduleOverlapPolicy
	// Timestamp used for the identity of the target workflow.
	// If not set the default value is the current time.
	ScheduledTime *timestamppb.Timestamp
}

func (b0 TriggerImmediatelyRequest_builder) Build() *TriggerImmediatelyRequest {
	m0 := &TriggerImmediatelyRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_OverlapPolicy = b.OverlapPolicy
	x.xxx_hidden_ScheduledTime = b.ScheduledTime
	return m0
}

type BackfillRequest struct {
	state                    protoimpl.MessageState   `protogen:"opaque.v1"`
	xxx_hidden_StartTime     *timestamppb.Timestamp   `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3"`
	xxx_hidden_EndTime       *timestamppb.Timestamp   `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3"`
	xxx_hidden_OverlapPolicy v1.ScheduleOverlapPolicy `protobuf:"varint,3,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=temporal.api.enums.v1.ScheduleOverlapPolicy"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *BackfillRequest) Reset() {
	*x = BackfillRequest{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BackfillRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackfillRequest) ProtoMessage() {}

func (x *BackfillRequest) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *BackfillRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_StartTime
	}
	return nil
}

func (x *BackfillRequest) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_EndTime
	}
	return nil
}

func (x *BackfillRequest) GetOverlapPolicy() v1.ScheduleOverlapPolicy {
	if x != nil {
		return x.xxx_hidden_OverlapPolicy
	}
	return v1.ScheduleOverlapPolicy(0)
}

func (x *BackfillRequest) SetStartTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_StartTime = v
}

func (x *BackfillRequest) SetEndTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_EndTime = v
}

func (x *BackfillRequest) SetOverlapPolicy(v v1.ScheduleOverlapPolicy) {
	x.xxx_hidden_OverlapPolicy = v
}

func (x *BackfillRequest) HasStartTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_StartTime != nil
}

func (x *BackfillRequest) HasEndTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_EndTime != nil
}

func (x *BackfillRequest) ClearStartTime() {
	x.xxx_hidden_StartTime = nil
}

func (x *BackfillRequest) ClearEndTime() {
	x.xxx_hidden_EndTime = nil
}

type BackfillRequest_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Time range to evaluate schedule in. Currently, this time range is
	// exclusive on start_time and inclusive on end_time. (This is admittedly
	// counterintuitive and it may change in the future, so to be safe, use a
	// start time strictly before a scheduled time.) Also note that an action
	// nominally scheduled in the interval but with jitter that pushes it after
	// end_time will not be included.
	StartTime *timestamppb.Timestamp
	EndTime   *timestamppb.Timestamp
	// If set, override overlap policy for this request.
	OverlapPolicy v1.ScheduleOverlapPolicy
}

func (b0 BackfillRequest_builder) Build() *BackfillRequest {
	m0 := &BackfillRequest{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_StartTime = b.StartTime
	x.xxx_hidden_EndTime = b.EndTime
	x.xxx_hidden_OverlapPolicy = b.OverlapPolicy
	return m0
}

type SchedulePatch struct {
	state                         protoimpl.MessageState     `protogen:"opaque.v1"`
	xxx_hidden_TriggerImmediately *TriggerImmediatelyRequest `protobuf:"bytes,1,opt,name=trigger_immediately,json=triggerImmediately,proto3"`
	xxx_hidden_BackfillRequest    *[]*BackfillRequest        `protobuf:"bytes,2,rep,name=backfill_request,json=backfillRequest,proto3"`
	xxx_hidden_Pause              string                     `protobuf:"bytes,3,opt,name=pause,proto3"`
	xxx_hidden_Unpause            string                     `protobuf:"bytes,4,opt,name=unpause,proto3"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *SchedulePatch) Reset() {
	*x = SchedulePatch{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePatch) ProtoMessage() {}

func (x *SchedulePatch) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SchedulePatch) GetTriggerImmediately() *TriggerImmediatelyRequest {
	if x != nil {
		return x.xxx_hidden_TriggerImmediately
	}
	return nil
}

func (x *SchedulePatch) GetBackfillRequest() []*BackfillRequest {
	if x != nil {
		if x.xxx_hidden_BackfillRequest != nil {
			return *x.xxx_hidden_BackfillRequest
		}
	}
	return nil
}

func (x *SchedulePatch) GetPause() string {
	if x != nil {
		return x.xxx_hidden_Pause
	}
	return ""
}

func (x *SchedulePatch) GetUnpause() string {
	if x != nil {
		return x.xxx_hidden_Unpause
	}
	return ""
}

func (x *SchedulePatch) SetTriggerImmediately(v *TriggerImmediatelyRequest) {
	x.xxx_hidden_TriggerImmediately = v
}

func (x *SchedulePatch) SetBackfillRequest(v []*BackfillRequest) {
	x.xxx_hidden_BackfillRequest = &v
}

func (x *SchedulePatch) SetPause(v string) {
	x.xxx_hidden_Pause = v
}

func (x *SchedulePatch) SetUnpause(v string) {
	x.xxx_hidden_Unpause = v
}

func (x *SchedulePatch) HasTriggerImmediately() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_TriggerImmediately != nil
}

func (x *SchedulePatch) ClearTriggerImmediately() {
	x.xxx_hidden_TriggerImmediately = nil
}

type SchedulePatch_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// If set, trigger one action immediately.
	TriggerImmediately *TriggerImmediatelyRequest
	// If set, runs though the specified time period(s) and takes actions as if that time
	// passed by right now, all at once. The overlap policy can be overridden for the
	// scope of the backfill.
	BackfillRequest []*BackfillRequest
	// If set, change the state to paused or unpaused (respectively) and set the
	// notes field to the value of the string.
	Pause   string
	Unpause string
}

func (b0 SchedulePatch_builder) Build() *SchedulePatch {
	m0 := &SchedulePatch{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_TriggerImmediately = b.TriggerImmediately
	x.xxx_hidden_BackfillRequest = &b.BackfillRequest
	x.xxx_hidden_Pause = b.Pause
	x.xxx_hidden_Unpause = b.Unpause
	return m0
}

type ScheduleInfo struct {
	state                           protoimpl.MessageState    `protogen:"opaque.v1"`
	xxx_hidden_ActionCount          int64                     `protobuf:"varint,1,opt,name=action_count,json=actionCount,proto3"`
	xxx_hidden_MissedCatchupWindow  int64                     `protobuf:"varint,2,opt,name=missed_catchup_window,json=missedCatchupWindow,proto3"`
	xxx_hidden_OverlapSkipped       int64                     `protobuf:"varint,3,opt,name=overlap_skipped,json=overlapSkipped,proto3"`
	xxx_hidden_BufferDropped        int64                     `protobuf:"varint,10,opt,name=buffer_dropped,json=bufferDropped,proto3"`
	xxx_hidden_BufferSize           int64                     `protobuf:"varint,11,opt,name=buffer_size,json=bufferSize,proto3"`
	xxx_hidden_RunningWorkflows     *[]*v12.WorkflowExecution `protobuf:"bytes,9,rep,name=running_workflows,json=runningWorkflows,proto3"`
	xxx_hidden_RecentActions        *[]*ScheduleActionResult  `protobuf:"bytes,4,rep,name=recent_actions,json=recentActions,proto3"`
	xxx_hidden_FutureActionTimes    *[]*timestamppb.Timestamp `protobuf:"bytes,5,rep,name=future_action_times,json=futureActionTimes,proto3"`
	xxx_hidden_CreateTime           *timestamppb.Timestamp    `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3"`
	xxx_hidden_UpdateTime           *timestamppb.Timestamp    `protobuf:"bytes,7,opt,name=update_time,json=updateTime,proto3"`
	xxx_hidden_InvalidScheduleError string                    `protobuf:"bytes,8,opt,name=invalid_schedule_error,json=invalidScheduleError,proto3"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *ScheduleInfo) Reset() {
	*x = ScheduleInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleInfo) ProtoMessage() {}

func (x *ScheduleInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleInfo) GetActionCount() int64 {
	if x != nil {
		return x.xxx_hidden_ActionCount
	}
	return 0
}

func (x *ScheduleInfo) GetMissedCatchupWindow() int64 {
	if x != nil {
		return x.xxx_hidden_MissedCatchupWindow
	}
	return 0
}

func (x *ScheduleInfo) GetOverlapSkipped() int64 {
	if x != nil {
		return x.xxx_hidden_OverlapSkipped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferDropped() int64 {
	if x != nil {
		return x.xxx_hidden_BufferDropped
	}
	return 0
}

func (x *ScheduleInfo) GetBufferSize() int64 {
	if x != nil {
		return x.xxx_hidden_BufferSize
	}
	return 0
}

func (x *ScheduleInfo) GetRunningWorkflows() []*v12.WorkflowExecution {
	if x != nil {
		if x.xxx_hidden_RunningWorkflows != nil {
			return *x.xxx_hidden_RunningWorkflows
		}
	}
	return nil
}

func (x *ScheduleInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		if x.xxx_hidden_RecentActions != nil {
			return *x.xxx_hidden_RecentActions
		}
	}
	return nil
}

func (x *ScheduleInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		if x.xxx_hidden_FutureActionTimes != nil {
			return *x.xxx_hidden_FutureActionTimes
		}
	}
	return nil
}

func (x *ScheduleInfo) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_CreateTime
	}
	return nil
}

func (x *ScheduleInfo) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_UpdateTime
	}
	return nil
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleInfo) GetInvalidScheduleError() string {
	if x != nil {
		return x.xxx_hidden_InvalidScheduleError
	}
	return ""
}

func (x *ScheduleInfo) SetActionCount(v int64) {
	x.xxx_hidden_ActionCount = v
}

func (x *ScheduleInfo) SetMissedCatchupWindow(v int64) {
	x.xxx_hidden_MissedCatchupWindow = v
}

func (x *ScheduleInfo) SetOverlapSkipped(v int64) {
	x.xxx_hidden_OverlapSkipped = v
}

func (x *ScheduleInfo) SetBufferDropped(v int64) {
	x.xxx_hidden_BufferDropped = v
}

func (x *ScheduleInfo) SetBufferSize(v int64) {
	x.xxx_hidden_BufferSize = v
}

func (x *ScheduleInfo) SetRunningWorkflows(v []*v12.WorkflowExecution) {
	x.xxx_hidden_RunningWorkflows = &v
}

func (x *ScheduleInfo) SetRecentActions(v []*ScheduleActionResult) {
	x.xxx_hidden_RecentActions = &v
}

func (x *ScheduleInfo) SetFutureActionTimes(v []*timestamppb.Timestamp) {
	x.xxx_hidden_FutureActionTimes = &v
}

func (x *ScheduleInfo) SetCreateTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_CreateTime = v
}

func (x *ScheduleInfo) SetUpdateTime(v *timestamppb.Timestamp) {
	x.xxx_hidden_UpdateTime = v
}

// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
func (x *ScheduleInfo) SetInvalidScheduleError(v string) {
	x.xxx_hidden_InvalidScheduleError = v
}

func (x *ScheduleInfo) HasCreateTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_CreateTime != nil
}

func (x *ScheduleInfo) HasUpdateTime() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_UpdateTime != nil
}

func (x *ScheduleInfo) ClearCreateTime() {
	x.xxx_hidden_CreateTime = nil
}

func (x *ScheduleInfo) ClearUpdateTime() {
	x.xxx_hidden_UpdateTime = nil
}

type ScheduleInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Number of actions taken so far.
	ActionCount int64
	// Number of times a scheduled action was skipped due to missing the catchup window.
	MissedCatchupWindow int64
	// Number of skipped actions due to overlap.
	OverlapSkipped int64
	// Number of dropped actions due to buffer limit.
	BufferDropped int64
	// Number of actions in the buffer. The buffer holds the actions that cannot
	// be immediately triggered (due to the overlap policy). These actions can be a result of
	// the normal schedule or a backfill.
	BufferSize int64
	// Currently-running workflows started by this schedule. (There might be
	// more than one if the overlap policy allows overlaps.)
	// Note that the run_ids in here are the original execution run ids as
	// started by the schedule. If the workflows retried, did continue-as-new,
	// or were reset, they might still be running but with a different run_id.
	RunningWorkflows []*v12.WorkflowExecution
	// Most recent ten actual action times (including manual triggers).
	RecentActions []*ScheduleActionResult
	// Next ten scheduled action times.
	FutureActionTimes []*timestamppb.Timestamp
	// Timestamps of schedule creation and last update.
	CreateTime *timestamppb.Timestamp
	UpdateTime *timestamppb.Timestamp
	// Deprecated.
	//
	// Deprecated: Marked as deprecated in temporal/api/schedule/v1/message.proto.
	InvalidScheduleError string
}

func (b0 ScheduleInfo_builder) Build() *ScheduleInfo {
	m0 := &ScheduleInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_ActionCount = b.ActionCount
	x.xxx_hidden_MissedCatchupWindow = b.MissedCatchupWindow
	x.xxx_hidden_OverlapSkipped = b.OverlapSkipped
	x.xxx_hidden_BufferDropped = b.BufferDropped
	x.xxx_hidden_BufferSize = b.BufferSize
	x.xxx_hidden_RunningWorkflows = &b.RunningWorkflows
	x.xxx_hidden_RecentActions = &b.RecentActions
	x.xxx_hidden_FutureActionTimes = &b.FutureActionTimes
	x.xxx_hidden_CreateTime = b.CreateTime
	x.xxx_hidden_UpdateTime = b.UpdateTime
	x.xxx_hidden_InvalidScheduleError = b.InvalidScheduleError
	return m0
}

type Schedule struct {
	state               protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_Spec     *ScheduleSpec          `protobuf:"bytes,1,opt,name=spec,proto3"`
	xxx_hidden_Action   *ScheduleAction        `protobuf:"bytes,2,opt,name=action,proto3"`
	xxx_hidden_Policies *SchedulePolicies      `protobuf:"bytes,3,opt,name=policies,proto3"`
	xxx_hidden_State    *ScheduleState         `protobuf:"bytes,4,opt,name=state,proto3"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Schedule) Reset() {
	*x = Schedule{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schedule) ProtoMessage() {}

func (x *Schedule) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Schedule) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.xxx_hidden_Spec
	}
	return nil
}

func (x *Schedule) GetAction() *ScheduleAction {
	if x != nil {
		return x.xxx_hidden_Action
	}
	return nil
}

func (x *Schedule) GetPolicies() *SchedulePolicies {
	if x != nil {
		return x.xxx_hidden_Policies
	}
	return nil
}

func (x *Schedule) GetState() *ScheduleState {
	if x != nil {
		return x.xxx_hidden_State
	}
	return nil
}

func (x *Schedule) SetSpec(v *ScheduleSpec) {
	x.xxx_hidden_Spec = v
}

func (x *Schedule) SetAction(v *ScheduleAction) {
	x.xxx_hidden_Action = v
}

func (x *Schedule) SetPolicies(v *SchedulePolicies) {
	x.xxx_hidden_Policies = v
}

func (x *Schedule) SetState(v *ScheduleState) {
	x.xxx_hidden_State = v
}

func (x *Schedule) HasSpec() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Spec != nil
}

func (x *Schedule) HasAction() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Action != nil
}

func (x *Schedule) HasPolicies() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Policies != nil
}

func (x *Schedule) HasState() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_State != nil
}

func (x *Schedule) ClearSpec() {
	x.xxx_hidden_Spec = nil
}

func (x *Schedule) ClearAction() {
	x.xxx_hidden_Action = nil
}

func (x *Schedule) ClearPolicies() {
	x.xxx_hidden_Policies = nil
}

func (x *Schedule) ClearState() {
	x.xxx_hidden_State = nil
}

type Schedule_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Spec     *ScheduleSpec
	Action   *ScheduleAction
	Policies *SchedulePolicies
	State    *ScheduleState
}

func (b0 Schedule_builder) Build() *Schedule {
	m0 := &Schedule{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Spec = b.Spec
	x.xxx_hidden_Action = b.Action
	x.xxx_hidden_Policies = b.Policies
	x.xxx_hidden_State = b.State
	return m0
}

// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
// that's returned in ListSchedules.
type ScheduleListInfo struct {
	state                        protoimpl.MessageState    `protogen:"opaque.v1"`
	xxx_hidden_Spec              *ScheduleSpec             `protobuf:"bytes,1,opt,name=spec,proto3"`
	xxx_hidden_WorkflowType      *v12.WorkflowType         `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3"`
	xxx_hidden_Notes             string                    `protobuf:"bytes,3,opt,name=notes,proto3"`
	xxx_hidden_Paused            bool                      `protobuf:"varint,4,opt,name=paused,proto3"`
	xxx_hidden_RecentActions     *[]*ScheduleActionResult  `protobuf:"bytes,5,rep,name=recent_actions,json=recentActions,proto3"`
	xxx_hidden_FutureActionTimes *[]*timestamppb.Timestamp `protobuf:"bytes,6,rep,name=future_action_times,json=futureActionTimes,proto3"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *ScheduleListInfo) Reset() {
	*x = ScheduleListInfo{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListInfo) ProtoMessage() {}

func (x *ScheduleListInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleListInfo) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.xxx_hidden_Spec
	}
	return nil
}

func (x *ScheduleListInfo) GetWorkflowType() *v12.WorkflowType {
	if x != nil {
		return x.xxx_hidden_WorkflowType
	}
	return nil
}

func (x *ScheduleListInfo) GetNotes() string {
	if x != nil {
		return x.xxx_hidden_Notes
	}
	return ""
}

func (x *ScheduleListInfo) GetPaused() bool {
	if x != nil {
		return x.xxx_hidden_Paused
	}
	return false
}

func (x *ScheduleListInfo) GetRecentActions() []*ScheduleActionResult {
	if x != nil {
		if x.xxx_hidden_RecentActions != nil {
			return *x.xxx_hidden_RecentActions
		}
	}
	return nil
}

func (x *ScheduleListInfo) GetFutureActionTimes() []*timestamppb.Timestamp {
	if x != nil {
		if x.xxx_hidden_FutureActionTimes != nil {
			return *x.xxx_hidden_FutureActionTimes
		}
	}
	return nil
}

func (x *ScheduleListInfo) SetSpec(v *ScheduleSpec) {
	x.xxx_hidden_Spec = v
}

func (x *ScheduleListInfo) SetWorkflowType(v *v12.WorkflowType) {
	x.xxx_hidden_WorkflowType = v
}

func (x *ScheduleListInfo) SetNotes(v string) {
	x.xxx_hidden_Notes = v
}

func (x *ScheduleListInfo) SetPaused(v bool) {
	x.xxx_hidden_Paused = v
}

func (x *ScheduleListInfo) SetRecentActions(v []*ScheduleActionResult) {
	x.xxx_hidden_RecentActions = &v
}

func (x *ScheduleListInfo) SetFutureActionTimes(v []*timestamppb.Timestamp) {
	x.xxx_hidden_FutureActionTimes = &v
}

func (x *ScheduleListInfo) HasSpec() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Spec != nil
}

func (x *ScheduleListInfo) HasWorkflowType() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_WorkflowType != nil
}

func (x *ScheduleListInfo) ClearSpec() {
	x.xxx_hidden_Spec = nil
}

func (x *ScheduleListInfo) ClearWorkflowType() {
	x.xxx_hidden_WorkflowType = nil
}

type ScheduleListInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// From spec:
	// Some fields are dropped from this copy of spec: timezone_data
	Spec *ScheduleSpec
	// From action:
	// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
	// well with JSON. If action is start_workflow, this is set:
	WorkflowType *v12.WorkflowType
	// From state:
	Notes  string
	Paused bool
	// From info (maybe fewer entries):
	RecentActions     []*ScheduleActionResult
	FutureActionTimes []*timestamppb.Timestamp
}

func (b0 ScheduleListInfo_builder) Build() *ScheduleListInfo {
	m0 := &ScheduleListInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_Spec = b.Spec
	x.xxx_hidden_WorkflowType = b.WorkflowType
	x.xxx_hidden_Notes = b.Notes
	x.xxx_hidden_Paused = b.Paused
	x.xxx_hidden_RecentActions = &b.RecentActions
	x.xxx_hidden_FutureActionTimes = &b.FutureActionTimes
	return m0
}

// ScheduleListEntry is returned by ListSchedules.
type ScheduleListEntry struct {
	state                       protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_ScheduleId       string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3"`
	xxx_hidden_Memo             *v12.Memo              `protobuf:"bytes,2,opt,name=memo,proto3"`
	xxx_hidden_SearchAttributes *v12.SearchAttributes  `protobuf:"bytes,3,opt,name=search_attributes,json=searchAttributes,proto3"`
	xxx_hidden_Info             *ScheduleListInfo      `protobuf:"bytes,4,opt,name=info,proto3"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *ScheduleListEntry) Reset() {
	*x = ScheduleListEntry{}
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleListEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleListEntry) ProtoMessage() {}

func (x *ScheduleListEntry) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_schedule_v1_message_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ScheduleListEntry) GetScheduleId() string {
	if x != nil {
		return x.xxx_hidden_ScheduleId
	}
	return ""
}

func (x *ScheduleListEntry) GetMemo() *v12.Memo {
	if x != nil {
		return x.xxx_hidden_Memo
	}
	return nil
}

func (x *ScheduleListEntry) GetSearchAttributes() *v12.SearchAttributes {
	if x != nil {
		return x.xxx_hidden_SearchAttributes
	}
	return nil
}

func (x *ScheduleListEntry) GetInfo() *ScheduleListInfo {
	if x != nil {
		return x.xxx_hidden_Info
	}
	return nil
}

func (x *ScheduleListEntry) SetScheduleId(v string) {
	x.xxx_hidden_ScheduleId = v
}

func (x *ScheduleListEntry) SetMemo(v *v12.Memo) {
	x.xxx_hidden_Memo = v
}

func (x *ScheduleListEntry) SetSearchAttributes(v *v12.SearchAttributes) {
	x.xxx_hidden_SearchAttributes = v
}

func (x *ScheduleListEntry) SetInfo(v *ScheduleListInfo) {
	x.xxx_hidden_Info = v
}

func (x *ScheduleListEntry) HasMemo() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Memo != nil
}

func (x *ScheduleListEntry) HasSearchAttributes() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_SearchAttributes != nil
}

func (x *ScheduleListEntry) HasInfo() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Info != nil
}

func (x *ScheduleListEntry) ClearMemo() {
	x.xxx_hidden_Memo = nil
}

func (x *ScheduleListEntry) ClearSearchAttributes() {
	x.xxx_hidden_SearchAttributes = nil
}

func (x *ScheduleListEntry) ClearInfo() {
	x.xxx_hidden_Info = nil
}

type ScheduleListEntry_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	ScheduleId       string
	Memo             *v12.Memo
	SearchAttributes *v12.SearchAttributes
	Info             *ScheduleListInfo
}

func (b0 ScheduleListEntry_builder) Build() *ScheduleListEntry {
	m0 := &ScheduleListEntry{}
	b, x := &b0, m0
	_, _ = b, x
	x.xxx_hidden_ScheduleId = b.ScheduleId
	x.xxx_hidden_Memo = b.Memo
	x.xxx_hidden_SearchAttributes = b.SearchAttributes
	x.xxx_hidden_Info = b.Info
	return m0
}

var File_temporal_api_schedule_v1_message_proto protoreflect.FileDescriptor

const file_temporal_api_schedule_v1_message_proto_rawDesc = "" +
	"\n" +
	"&temporal/api/schedule/v1/message.proto\x12\x18temporal.api.schedule.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a$temporal/api/common/v1/message.proto\x1a$temporal/api/enums/v1/schedule.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a&temporal/api/workflow/v1/message.proto\"\xd8\x01\n" +
	"\fCalendarSpec\x12\x16\n" +
	"\x06second\x18\x01 \x01(\tR\x06second\x12\x16\n" +
	"\x06minute\x18\x02 \x01(\tR\x06minute\x12\x12\n" +
	"\x04hour\x18\x03 \x01(\tR\x04hour\x12 \n" +
	"\fday_of_month\x18\x04 \x01(\tR\n" +
	"dayOfMonth\x12\x14\n" +
	"\x05month\x18\x05 \x01(\tR\x05month\x12\x12\n" +
	"\x04year\x18\x06 \x01(\tR\x04year\x12\x1e\n" +
	"\vday_of_week\x18\a \x01(\tR\tdayOfWeek\x12\x18\n" +
	"\acomment\x18\b \x01(\tR\acomment\"C\n" +
	"\x05Range\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x05R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x05R\x03end\x12\x12\n" +
	"\x04step\x18\x03 \x01(\x05R\x04step\"\xc9\x03\n" +
	"\x16StructuredCalendarSpec\x127\n" +
	"\x06second\x18\x01 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x06second\x127\n" +
	"\x06minute\x18\x02 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x06minute\x123\n" +
	"\x04hour\x18\x03 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x04hour\x12A\n" +
	"\fday_of_month\x18\x04 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\n" +
	"dayOfMonth\x125\n" +
	"\x05month\x18\x05 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x05month\x123\n" +
	"\x04year\x18\x06 \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\x04year\x12?\n" +
	"\vday_of_week\x18\a \x03(\v2\x1f.temporal.api.schedule.v1.RangeR\tdayOfWeek\x12\x18\n" +
	"\acomment\x18\b \x01(\tR\acomment\"v\n" +
	"\fIntervalSpec\x125\n" +
	"\binterval\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\binterval\x12/\n" +
	"\x05phase\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x05phase\"\xd2\x05\n" +
	"\fScheduleSpec\x12a\n" +
	"\x13structured_calendar\x18\a \x03(\v20.temporal.api.schedule.v1.StructuredCalendarSpecR\x12structuredCalendar\x12\x1f\n" +
	"\vcron_string\x18\b \x03(\tR\n" +
	"cronString\x12B\n" +
	"\bcalendar\x18\x01 \x03(\v2&.temporal.api.schedule.v1.CalendarSpecR\bcalendar\x12B\n" +
	"\binterval\x18\x02 \x03(\v2&.temporal.api.schedule.v1.IntervalSpecR\binterval\x12U\n" +
	"\x10exclude_calendar\x18\x03 \x03(\v2&.temporal.api.schedule.v1.CalendarSpecB\x02\x18\x01R\x0fexcludeCalendar\x12p\n" +
	"\x1bexclude_structured_calendar\x18\t \x03(\v20.temporal.api.schedule.v1.StructuredCalendarSpecR\x19excludeStructuredCalendar\x129\n" +
	"\n" +
	"start_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x121\n" +
	"\x06jitter\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x06jitter\x12#\n" +
	"\rtimezone_name\x18\n" +
	" \x01(\tR\ftimezoneName\x12#\n" +
	"\rtimezone_data\x18\v \x01(\fR\ftimezoneData\"\x8e\x02\n" +
	"\x10SchedulePolicies\x12S\n" +
	"\x0eoverlap_policy\x18\x01 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\x12@\n" +
	"\x0ecatchup_window\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\rcatchupWindow\x12(\n" +
	"\x10pause_on_failure\x18\x03 \x01(\bR\x0epauseOnFailure\x129\n" +
	"\x19keep_original_workflow_id\x18\x04 \x01(\bR\x16keepOriginalWorkflowId\"w\n" +
	"\x0eScheduleAction\x12[\n" +
	"\x0estart_workflow\x18\x01 \x01(\v22.temporal.api.workflow.v1.NewWorkflowExecutionInfoH\x00R\rstartWorkflowB\b\n" +
	"\x06action\"\xd7\x02\n" +
	"\x14ScheduleActionResult\x12?\n" +
	"\rschedule_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\fscheduleTime\x12;\n" +
	"\vactual_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"actualTime\x12]\n" +
	"\x15start_workflow_result\x18\v \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\x13startWorkflowResult\x12b\n" +
	"\x15start_workflow_status\x18\f \x01(\x0e2..temporal.api.enums.v1.WorkflowExecutionStatusR\x13startWorkflowStatus\"\x93\x01\n" +
	"\rScheduleState\x12\x14\n" +
	"\x05notes\x18\x01 \x01(\tR\x05notes\x12\x16\n" +
	"\x06paused\x18\x02 \x01(\bR\x06paused\x12'\n" +
	"\x0flimited_actions\x18\x03 \x01(\bR\x0elimitedActions\x12+\n" +
	"\x11remaining_actions\x18\x04 \x01(\x03R\x10remainingActions\"\xb3\x01\n" +
	"\x19TriggerImmediatelyRequest\x12S\n" +
	"\x0eoverlap_policy\x18\x01 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\x12A\n" +
	"\x0escheduled_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledTime\"\xd8\x01\n" +
	"\x0fBackfillRequest\x129\n" +
	"\n" +
	"start_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x125\n" +
	"\bend_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x12S\n" +
	"\x0eoverlap_policy\x18\x03 \x01(\x0e2,.temporal.api.enums.v1.ScheduleOverlapPolicyR\roverlapPolicy\"\xfb\x01\n" +
	"\rSchedulePatch\x12d\n" +
	"\x13trigger_immediately\x18\x01 \x01(\v23.temporal.api.schedule.v1.TriggerImmediatelyRequestR\x12triggerImmediately\x12T\n" +
	"\x10backfill_request\x18\x02 \x03(\v2).temporal.api.schedule.v1.BackfillRequestR\x0fbackfillRequest\x12\x14\n" +
	"\x05pause\x18\x03 \x01(\tR\x05pause\x12\x18\n" +
	"\aunpause\x18\x04 \x01(\tR\aunpause\"\x85\x05\n" +
	"\fScheduleInfo\x12!\n" +
	"\faction_count\x18\x01 \x01(\x03R\vactionCount\x122\n" +
	"\x15missed_catchup_window\x18\x02 \x01(\x03R\x13missedCatchupWindow\x12'\n" +
	"\x0foverlap_skipped\x18\x03 \x01(\x03R\x0eoverlapSkipped\x12%\n" +
	"\x0ebuffer_dropped\x18\n" +
	" \x01(\x03R\rbufferDropped\x12\x1f\n" +
	"\vbuffer_size\x18\v \x01(\x03R\n" +
	"bufferSize\x12V\n" +
	"\x11running_workflows\x18\t \x03(\v2).temporal.api.common.v1.WorkflowExecutionR\x10runningWorkflows\x12U\n" +
	"\x0erecent_actions\x18\x04 \x03(\v2..temporal.api.schedule.v1.ScheduleActionResultR\rrecentActions\x12J\n" +
	"\x13future_action_times\x18\x05 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\x12;\n" +
	"\vcreate_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12;\n" +
	"\vupdate_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateTime\x128\n" +
	"\x16invalid_schedule_error\x18\b \x01(\tB\x02\x18\x01R\x14invalidScheduleError\"\x8f\x02\n" +
	"\bSchedule\x12:\n" +
	"\x04spec\x18\x01 \x01(\v2&.temporal.api.schedule.v1.ScheduleSpecR\x04spec\x12@\n" +
	"\x06action\x18\x02 \x01(\v2(.temporal.api.schedule.v1.ScheduleActionR\x06action\x12F\n" +
	"\bpolicies\x18\x03 \x01(\v2*.temporal.api.schedule.v1.SchedulePoliciesR\bpolicies\x12=\n" +
	"\x05state\x18\x04 \x01(\v2'.temporal.api.schedule.v1.ScheduleStateR\x05state\"\xea\x02\n" +
	"\x10ScheduleListInfo\x12:\n" +
	"\x04spec\x18\x01 \x01(\v2&.temporal.api.schedule.v1.ScheduleSpecR\x04spec\x12I\n" +
	"\rworkflow_type\x18\x02 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\fworkflowType\x12\x14\n" +
	"\x05notes\x18\x03 \x01(\tR\x05notes\x12\x16\n" +
	"\x06paused\x18\x04 \x01(\bR\x06paused\x12U\n" +
	"\x0erecent_actions\x18\x05 \x03(\v2..temporal.api.schedule.v1.ScheduleActionResultR\rrecentActions\x12J\n" +
	"\x13future_action_times\x18\x06 \x03(\v2\x1a.google.protobuf.TimestampR\x11futureActionTimes\"\xfd\x01\n" +
	"\x11ScheduleListEntry\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\x120\n" +
	"\x04memo\x18\x02 \x01(\v2\x1c.temporal.api.common.v1.MemoR\x04memo\x12U\n" +
	"\x11search_attributes\x18\x03 \x01(\v2(.temporal.api.common.v1.SearchAttributesR\x10searchAttributes\x12>\n" +
	"\x04info\x18\x04 \x01(\v2*.temporal.api.schedule.v1.ScheduleListInfoR\x04infoB\x93\x01\n" +
	"\x1bio.temporal.api.schedule.v1B\fMessageProtoP\x01Z'go.temporal.io/api/schedule/v1;schedule\xaa\x02\x1aTemporalio.Api.Schedule.V1\xea\x02\x1dTemporalio::Api::Schedule::V1b\x06proto3"

var file_temporal_api_schedule_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_temporal_api_schedule_v1_message_proto_goTypes = []any{
	(*CalendarSpec)(nil),                 // 0: temporal.api.schedule.v1.CalendarSpec
	(*Range)(nil),                        // 1: temporal.api.schedule.v1.Range
	(*StructuredCalendarSpec)(nil),       // 2: temporal.api.schedule.v1.StructuredCalendarSpec
	(*IntervalSpec)(nil),                 // 3: temporal.api.schedule.v1.IntervalSpec
	(*ScheduleSpec)(nil),                 // 4: temporal.api.schedule.v1.ScheduleSpec
	(*SchedulePolicies)(nil),             // 5: temporal.api.schedule.v1.SchedulePolicies
	(*ScheduleAction)(nil),               // 6: temporal.api.schedule.v1.ScheduleAction
	(*ScheduleActionResult)(nil),         // 7: temporal.api.schedule.v1.ScheduleActionResult
	(*ScheduleState)(nil),                // 8: temporal.api.schedule.v1.ScheduleState
	(*TriggerImmediatelyRequest)(nil),    // 9: temporal.api.schedule.v1.TriggerImmediatelyRequest
	(*BackfillRequest)(nil),              // 10: temporal.api.schedule.v1.BackfillRequest
	(*SchedulePatch)(nil),                // 11: temporal.api.schedule.v1.SchedulePatch
	(*ScheduleInfo)(nil),                 // 12: temporal.api.schedule.v1.ScheduleInfo
	(*Schedule)(nil),                     // 13: temporal.api.schedule.v1.Schedule
	(*ScheduleListInfo)(nil),             // 14: temporal.api.schedule.v1.ScheduleListInfo
	(*ScheduleListEntry)(nil),            // 15: temporal.api.schedule.v1.ScheduleListEntry
	(*durationpb.Duration)(nil),          // 16: google.protobuf.Duration
	(*timestamppb.Timestamp)(nil),        // 17: google.protobuf.Timestamp
	(v1.ScheduleOverlapPolicy)(0),        // 18: temporal.api.enums.v1.ScheduleOverlapPolicy
	(*v11.NewWorkflowExecutionInfo)(nil), // 19: temporal.api.workflow.v1.NewWorkflowExecutionInfo
	(*v12.WorkflowExecution)(nil),        // 20: temporal.api.common.v1.WorkflowExecution
	(v1.WorkflowExecutionStatus)(0),      // 21: temporal.api.enums.v1.WorkflowExecutionStatus
	(*v12.WorkflowType)(nil),             // 22: temporal.api.common.v1.WorkflowType
	(*v12.Memo)(nil),                     // 23: temporal.api.common.v1.Memo
	(*v12.SearchAttributes)(nil),         // 24: temporal.api.common.v1.SearchAttributes
}
var file_temporal_api_schedule_v1_message_proto_depIdxs = []int32{
	1,  // 0: temporal.api.schedule.v1.StructuredCalendarSpec.second:type_name -> temporal.api.schedule.v1.Range
	1,  // 1: temporal.api.schedule.v1.StructuredCalendarSpec.minute:type_name -> temporal.api.schedule.v1.Range
	1,  // 2: temporal.api.schedule.v1.StructuredCalendarSpec.hour:type_name -> temporal.api.schedule.v1.Range
	1,  // 3: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_month:type_name -> temporal.api.schedule.v1.Range
	1,  // 4: temporal.api.schedule.v1.StructuredCalendarSpec.month:type_name -> temporal.api.schedule.v1.Range
	1,  // 5: temporal.api.schedule.v1.StructuredCalendarSpec.year:type_name -> temporal.api.schedule.v1.Range
	1,  // 6: temporal.api.schedule.v1.StructuredCalendarSpec.day_of_week:type_name -> temporal.api.schedule.v1.Range
	16, // 7: temporal.api.schedule.v1.IntervalSpec.interval:type_name -> google.protobuf.Duration
	16, // 8: temporal.api.schedule.v1.IntervalSpec.phase:type_name -> google.protobuf.Duration
	2,  // 9: temporal.api.schedule.v1.ScheduleSpec.structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	0,  // 10: temporal.api.schedule.v1.ScheduleSpec.calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	3,  // 11: temporal.api.schedule.v1.ScheduleSpec.interval:type_name -> temporal.api.schedule.v1.IntervalSpec
	0,  // 12: temporal.api.schedule.v1.ScheduleSpec.exclude_calendar:type_name -> temporal.api.schedule.v1.CalendarSpec
	2,  // 13: temporal.api.schedule.v1.ScheduleSpec.exclude_structured_calendar:type_name -> temporal.api.schedule.v1.StructuredCalendarSpec
	17, // 14: temporal.api.schedule.v1.ScheduleSpec.start_time:type_name -> google.protobuf.Timestamp
	17, // 15: temporal.api.schedule.v1.ScheduleSpec.end_time:type_name -> google.protobuf.Timestamp
	16, // 16: temporal.api.schedule.v1.ScheduleSpec.jitter:type_name -> google.protobuf.Duration
	18, // 17: temporal.api.schedule.v1.SchedulePolicies.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	16, // 18: temporal.api.schedule.v1.SchedulePolicies.catchup_window:type_name -> google.protobuf.Duration
	19, // 19: temporal.api.schedule.v1.ScheduleAction.start_workflow:type_name -> temporal.api.workflow.v1.NewWorkflowExecutionInfo
	17, // 20: temporal.api.schedule.v1.ScheduleActionResult.schedule_time:type_name -> google.protobuf.Timestamp
	17, // 21: temporal.api.schedule.v1.ScheduleActionResult.actual_time:type_name -> google.protobuf.Timestamp
	20, // 22: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_result:type_name -> temporal.api.common.v1.WorkflowExecution
	21, // 23: temporal.api.schedule.v1.ScheduleActionResult.start_workflow_status:type_name -> temporal.api.enums.v1.WorkflowExecutionStatus
	18, // 24: temporal.api.schedule.v1.TriggerImmediatelyRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	17, // 25: temporal.api.schedule.v1.TriggerImmediatelyRequest.scheduled_time:type_name -> google.protobuf.Timestamp
	17, // 26: temporal.api.schedule.v1.BackfillRequest.start_time:type_name -> google.protobuf.Timestamp
	17, // 27: temporal.api.schedule.v1.BackfillRequest.end_time:type_name -> google.protobuf.Timestamp
	18, // 28: temporal.api.schedule.v1.BackfillRequest.overlap_policy:type_name -> temporal.api.enums.v1.ScheduleOverlapPolicy
	9,  // 29: temporal.api.schedule.v1.SchedulePatch.trigger_immediately:type_name -> temporal.api.schedule.v1.TriggerImmediatelyRequest
	10, // 30: temporal.api.schedule.v1.SchedulePatch.backfill_request:type_name -> temporal.api.schedule.v1.BackfillRequest
	20, // 31: temporal.api.schedule.v1.ScheduleInfo.running_workflows:type_name -> temporal.api.common.v1.WorkflowExecution
	7,  // 32: temporal.api.schedule.v1.ScheduleInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 33: temporal.api.schedule.v1.ScheduleInfo.future_action_times:type_name -> google.protobuf.Timestamp
	17, // 34: temporal.api.schedule.v1.ScheduleInfo.create_time:type_name -> google.protobuf.Timestamp
	17, // 35: temporal.api.schedule.v1.ScheduleInfo.update_time:type_name -> google.protobuf.Timestamp
	4,  // 36: temporal.api.schedule.v1.Schedule.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	6,  // 37: temporal.api.schedule.v1.Schedule.action:type_name -> temporal.api.schedule.v1.ScheduleAction
	5,  // 38: temporal.api.schedule.v1.Schedule.policies:type_name -> temporal.api.schedule.v1.SchedulePolicies
	8,  // 39: temporal.api.schedule.v1.Schedule.state:type_name -> temporal.api.schedule.v1.ScheduleState
	4,  // 40: temporal.api.schedule.v1.ScheduleListInfo.spec:type_name -> temporal.api.schedule.v1.ScheduleSpec
	22, // 41: temporal.api.schedule.v1.ScheduleListInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	7,  // 42: temporal.api.schedule.v1.ScheduleListInfo.recent_actions:type_name -> temporal.api.schedule.v1.ScheduleActionResult
	17, // 43: temporal.api.schedule.v1.ScheduleListInfo.future_action_times:type_name -> google.protobuf.Timestamp
	23, // 44: temporal.api.schedule.v1.ScheduleListEntry.memo:type_name -> temporal.api.common.v1.Memo
	24, // 45: temporal.api.schedule.v1.ScheduleListEntry.search_attributes:type_name -> temporal.api.common.v1.SearchAttributes
	14, // 46: temporal.api.schedule.v1.ScheduleListEntry.info:type_name -> temporal.api.schedule.v1.ScheduleListInfo
	47, // [47:47] is the sub-list for method output_type
	47, // [47:47] is the sub-list for method input_type
	47, // [47:47] is the sub-list for extension type_name
	47, // [47:47] is the sub-list for extension extendee
	0,  // [0:47] is the sub-list for field type_name
}

func init() { file_temporal_api_schedule_v1_message_proto_init() }
func file_temporal_api_schedule_v1_message_proto_init() {
	if File_temporal_api_schedule_v1_message_proto != nil {
		return
	}
	file_temporal_api_schedule_v1_message_proto_msgTypes[6].OneofWrappers = []any{
		(*scheduleAction_StartWorkflow)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_api_schedule_v1_message_proto_rawDesc), len(file_temporal_api_schedule_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_schedule_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_schedule_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_api_schedule_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_schedule_v1_message_proto = out.File
	file_temporal_api_schedule_v1_message_proto_goTypes = nil
	file_temporal_api_schedule_v1_message_proto_depIdxs = nil
}
