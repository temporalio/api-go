// The MIT License
//
// Copyright (c) 2022 Temporal Technologies Inc.  All rights reserved.
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by go generate; DO NOT EDIT.

package proxy

import (
	"context"
	"fmt"

	"google.golang.org/grpc"

	batchpb "go.temporal.io/api/batch/v1"
	commandpb "go.temporal.io/api/command/v1"
	commonpb "go.temporal.io/api/common/v1"
	failurepb "go.temporal.io/api/failure/v1"
	historypb "go.temporal.io/api/history/v1"
	interactionpb "go.temporal.io/api/interaction/v1"
	querypb "go.temporal.io/api/query/v1"
	schedulepb "go.temporal.io/api/schedule/v1"
	workflowpb "go.temporal.io/api/workflow/v1"
	workflowservicepb "go.temporal.io/api/workflowservice/v1"
)

type VisitPayloadsContext struct {
	context.Context
	Parent interface{}
	// If true, a single payload is given and a single payload must be returned
	SinglePayloadRequired bool
}

type VisitPayloadsOptions struct {
	// Context is the same for every call of a visit, callers should not store it. This must never
	// return an empty set of payloads.
	Visitor              func(*VisitPayloadsContext, []*commonpb.Payload) ([]*commonpb.Payload, error)
	SkipSearchAttributes bool
}

func VisitPayloads(ctx context.Context, msg interface{}, options VisitPayloadsOptions) error {
	visitCtx := VisitPayloadsContext{Context: ctx, Parent: msg}

	return visitPayloads(&visitCtx, &options, msg)
}

type PayloadVisitorInterceptorOptions struct {
	Outbound *VisitPayloadsOptions
	Inbound  *VisitPayloadsOptions
}

func visitPayload(ctx *VisitPayloadsContext, options *VisitPayloadsOptions, msg *commonpb.Payload) error {
	ctx.SinglePayloadRequired = true

	newPayloads, err := options.Visitor(ctx, []*commonpb.Payload{msg})
	if err != nil {
		return err
	}

	if len(newPayloads) != 1 {
		return fmt.Errorf("visitor func must return 1 payload when SinglePayloadRequired = true")
	}

	msg = newPayloads[0]

	return nil
}

func visitPayloads(ctx *VisitPayloadsContext, options *VisitPayloadsOptions, objs ...interface{}) error {
	for _, obj := range objs {
		ctx.SinglePayloadRequired = false

		switch o := obj.(type) {
		case *commonpb.Payload:
			if o == nil {
				continue
			}
			err := visitPayload(ctx, options, o)
			if err != nil {
				return err
			}
		case map[string]*commonpb.Payload:
			for _, x := range o {
				if err := visitPayload(ctx, options, x); err != nil {
					return err
				}
			}
		case *commonpb.Payloads:
			if o == nil {
				continue
			}
			newPayloads, err := options.Visitor(ctx, o.Payloads)
			if err != nil {
				return err
			}
			o.Payloads = newPayloads

		case *batchpb.BatchOperationSignal:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *batchpb.BatchOperationTermination:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *commandpb.AcceptWorkflowUpdateCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *commandpb.CancelWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*commandpb.Command:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *commandpb.Command:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetAcceptWorkflowUpdateCommandAttributes(),
				o.GetCancelWorkflowExecutionCommandAttributes(),
				o.GetCompleteWorkflowExecutionCommandAttributes(),
				o.GetCompleteWorkflowUpdateCommandAttributes(),
				o.GetContinueAsNewWorkflowExecutionCommandAttributes(),
				o.GetFailWorkflowExecutionCommandAttributes(),
				o.GetModifyWorkflowPropertiesCommandAttributes(),
				o.GetRecordMarkerCommandAttributes(),
				o.GetRejectWorkflowUpdateCommandAttributes(),
				o.GetScheduleActivityTaskCommandAttributes(),
				o.GetSignalExternalWorkflowExecutionCommandAttributes(),
				o.GetStartChildWorkflowExecutionCommandAttributes(),
				o.GetUpsertWorkflowSearchAttributesCommandAttributes(),
			); err != nil {
				return err
			}

		case *commandpb.CompleteWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *commandpb.CompleteWorkflowUpdateCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutput(),
			); err != nil {
				return err
			}

		case *commandpb.ContinueAsNewWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *commandpb.FailWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *commandpb.ModifyWorkflowPropertiesCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *commandpb.RecordMarkerCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *commandpb.RejectWorkflowUpdateCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *commandpb.ScheduleActivityTaskCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *commandpb.SignalExternalWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *commandpb.StartChildWorkflowExecutionCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *commandpb.UpsertWorkflowSearchAttributesCommandAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *commonpb.Header:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *commonpb.Memo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFields(),
			); err != nil {
				return err
			}

		case *commonpb.SearchAttributes:

			if options.SkipSearchAttributes {
				continue
			}

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetIndexedFields(),
			); err != nil {
				return err
			}

		case *failurepb.ApplicationFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *failurepb.CanceledFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case []*failurepb.Failure:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *failurepb.Failure:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetApplicationFailureInfo(),
				o.GetCanceledFailureInfo(),
				o.GetCause(),
				o.GetEncodedAttributes(),
				o.GetResetWorkflowFailureInfo(),
				o.GetTimeoutFailureInfo(),
			); err != nil {
				return err
			}

		case *failurepb.ResetWorkflowFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *failurepb.TimeoutFailureInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskScheduledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case *historypb.ActivityTaskTimedOutEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *historypb.ChildWorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *historypb.ChildWorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *historypb.ChildWorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *historypb.ChildWorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *historypb.History:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetEvents(),
			); err != nil {
				return err
			}

		case []*historypb.HistoryEvent:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *historypb.HistoryEvent:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetActivityTaskCanceledEventAttributes(),
				o.GetActivityTaskCompletedEventAttributes(),
				o.GetActivityTaskFailedEventAttributes(),
				o.GetActivityTaskScheduledEventAttributes(),
				o.GetActivityTaskStartedEventAttributes(),
				o.GetActivityTaskTimedOutEventAttributes(),
				o.GetChildWorkflowExecutionCanceledEventAttributes(),
				o.GetChildWorkflowExecutionCompletedEventAttributes(),
				o.GetChildWorkflowExecutionFailedEventAttributes(),
				o.GetChildWorkflowExecutionStartedEventAttributes(),
				o.GetMarkerRecordedEventAttributes(),
				o.GetSignalExternalWorkflowExecutionInitiatedEventAttributes(),
				o.GetStartChildWorkflowExecutionInitiatedEventAttributes(),
				o.GetUpsertWorkflowSearchAttributesEventAttributes(),
				o.GetWorkflowExecutionCanceledEventAttributes(),
				o.GetWorkflowExecutionCompletedEventAttributes(),
				o.GetWorkflowExecutionContinuedAsNewEventAttributes(),
				o.GetWorkflowExecutionFailedEventAttributes(),
				o.GetWorkflowExecutionSignaledEventAttributes(),
				o.GetWorkflowExecutionStartedEventAttributes(),
				o.GetWorkflowExecutionTerminatedEventAttributes(),
				o.GetWorkflowPropertiesModifiedEventAttributes(),
				o.GetWorkflowPropertiesModifiedExternallyEventAttributes(),
				o.GetWorkflowTaskFailedEventAttributes(),
				o.GetWorkflowUpdateAcceptedEventAttributes(),
				o.GetWorkflowUpdateCompletedEventAttributes(),
				o.GetWorkflowUpdateRejectedEventAttributes(),
			); err != nil {
				return err
			}

		case *historypb.MarkerRecordedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
				o.GetFailure(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case *historypb.SignalExternalWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *historypb.StartChildWorkflowExecutionInitiatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *historypb.UpsertWorkflowSearchAttributesEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionCanceledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionContinuedAsNewEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionSignaledEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionStartedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetContinuedFailure(),
				o.GetHeader(),
				o.GetInput(),
				o.GetLastCompletionResult(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowExecutionTerminatedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowPropertiesModifiedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowPropertiesModifiedExternallyEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetUpsertedMemo(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowTaskFailedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowUpdateAcceptedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowUpdateCompletedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutput(),
			); err != nil {
				return err
			}

		case *historypb.WorkflowUpdateRejectedEventAttributes:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *interactionpb.Input:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetArgs(),
				o.GetHeader(),
			); err != nil {
				return err
			}

		case []*interactionpb.Invocation:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *interactionpb.Invocation:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *interactionpb.Output:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetHeader(),
				o.GetSuccess(),
			); err != nil {
				return err
			}

		case map[string]*querypb.WorkflowQuery:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *querypb.WorkflowQuery:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetQueryArgs(),
			); err != nil {
				return err
			}

		case map[string]*querypb.WorkflowQueryResult:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *querypb.WorkflowQueryResult:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetAnswer(),
			); err != nil {
				return err
			}

		case *schedulepb.Schedule:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetAction(),
			); err != nil {
				return err
			}

		case *schedulepb.ScheduleAction:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetStartWorkflow(),
			); err != nil {
				return err
			}

		case []*schedulepb.ScheduleListEntry:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *schedulepb.ScheduleListEntry:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowpb.NewWorkflowExecutionInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case []*workflowpb.PendingActivityInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowpb.PendingActivityInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeartbeatDetails(),
				o.GetLastFailure(),
			); err != nil {
				return err
			}

		case []*workflowpb.WorkflowExecutionInfo:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowpb.WorkflowExecutionInfo:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservicepb.CreateScheduleRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservicepb.DescribeScheduleResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetMemo(),
				o.GetSchedule(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservicepb.DescribeWorkflowExecutionResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetPendingActivities(),
				o.GetWorkflowExecutionInfo(),
			); err != nil {
				return err
			}

		case *workflowservicepb.GetWorkflowExecutionHistoryResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservicepb.GetWorkflowExecutionHistoryReverseResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ListArchivedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ListClosedWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ListOpenWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ListSchedulesResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetSchedules(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ListWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case []*workflowservicepb.PollActivityTaskQueueResponse:
			for _, x := range o {
				if err := visitPayloads(ctx, options, x); err != nil {
					return err
				}
			}

		case *workflowservicepb.PollActivityTaskQueueResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetHeartbeatDetails(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservicepb.PollWorkflowTaskQueueResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHistory(),
				o.GetInteractions(),
				o.GetQueries(),
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservicepb.QueryWorkflowRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetQuery(),
			); err != nil {
				return err
			}

		case *workflowservicepb.QueryWorkflowResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RecordActivityTaskHeartbeatByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RecordActivityTaskHeartbeatRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskCanceledByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskCanceledRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskCompletedByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetResult(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskFailedByIdRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskFailedByIdResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskFailedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
				o.GetLastHeartbeatDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondActivityTaskFailedResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailures(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondQueryTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetQueryResult(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondWorkflowTaskCompletedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetCommands(),
				o.GetQueryResults(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondWorkflowTaskCompletedResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetActivityTasks(),
				o.GetWorkflowTask(),
			); err != nil {
				return err
			}

		case *workflowservicepb.RespondWorkflowTaskFailedRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetFailure(),
			); err != nil {
				return err
			}

		case *workflowservicepb.ScanWorkflowExecutionsResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetExecutions(),
			); err != nil {
				return err
			}

		case *workflowservicepb.SignalWithStartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
				o.GetSignalInput(),
			); err != nil {
				return err
			}

		case *workflowservicepb.SignalWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservicepb.StartBatchOperationRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetSignalOperation(),
				o.GetTerminationOperation(),
			); err != nil {
				return err
			}

		case *workflowservicepb.StartWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetHeader(),
				o.GetInput(),
				o.GetMemo(),
				o.GetSearchAttributes(),
			); err != nil {
				return err
			}

		case *workflowservicepb.TerminateWorkflowExecutionRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetDetails(),
			); err != nil {
				return err
			}

		case *workflowservicepb.UpdateScheduleRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetSchedule(),
			); err != nil {
				return err
			}

		case *workflowservicepb.UpdateWorkflowRequest:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetInput(),
			); err != nil {
				return err
			}

		case *workflowservicepb.UpdateWorkflowResponse:

			if o == nil {
				continue
			}
			if err := visitPayloads(
				ctx,
				options,
				o.GetOutput(),
			); err != nil {
				return err
			}

		}
	}

	return nil
}

func NewPayloadVisitorInterceptor(options PayloadVisitorInterceptorOptions) (grpc.UnaryClientInterceptor, error) {
	return func(ctx context.Context, method string, req, response interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		err := VisitPayloads(ctx, req, *options.Outbound)
		if err != nil {
			return err
		}

		err = invoker(ctx, method, req, response, cc, opts...)
		if err != nil {
			return err
		}

		return VisitPayloads(ctx, response, *options.Inbound)
	}, nil
}
