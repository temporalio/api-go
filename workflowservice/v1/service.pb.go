// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: temporal/api/workflowservice/v1/service.proto

package workflowservice

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() {
	proto.RegisterFile("temporal/api/workflowservice/v1/service.proto", fileDescriptor_bded41be6e20a31f)
}

var fileDescriptor_bded41be6e20a31f = []byte{
	// 1045 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x99, 0xcd, 0x8b, 0x1c, 0x45,
	0x18, 0xc6, 0xa7, 0x2e, 0x1e, 0x0a, 0x35, 0xd8, 0x8a, 0xe2, 0xaa, 0x1d, 0xc9, 0xdd, 0x59, 0xa3,
	0x64, 0xd5, 0x24, 0x26, 0xce, 0xc7, 0xee, 0xcc, 0x82, 0xe8, 0x66, 0x27, 0x22, 0x78, 0x91, 0xda,
	0x9e, 0x37, 0xbb, 0xc5, 0xce, 0x76, 0xb5, 0x55, 0x35, 0x13, 0xf7, 0x16, 0x10, 0x3c, 0x09, 0x8a,
	0xe0, 0x49, 0xd0, 0x8b, 0xa0, 0x04, 0x04, 0x41, 0x10, 0xfc, 0x0f, 0x3c, 0xee, 0x31, 0x47, 0x77,
	0xf6, 0xe2, 0x31, 0x7f, 0x82, 0xcc, 0x47, 0x95, 0x5d, 0xdd, 0x55, 0xdd, 0xd5, 0xdd, 0xde, 0xf6,
	0xe3, 0x79, 0x9e, 0xfa, 0x51, 0xef, 0xf4, 0x3b, 0x6f, 0x55, 0xe3, 0xd7, 0x24, 0x9c, 0x24, 0x8c,
	0x93, 0xc9, 0x26, 0x49, 0xe8, 0xe6, 0x7d, 0xc6, 0x8f, 0xef, 0x4d, 0xd8, 0x7d, 0x01, 0x7c, 0x46,
	0x23, 0xd8, 0x9c, 0x5d, 0xdd, 0x5c, 0xff, 0xd8, 0x4e, 0x38, 0x93, 0x2c, 0xb8, 0xac, 0xe4, 0x6d,
	0x92, 0xd0, 0x76, 0x46, 0xde, 0x9e, 0x5d, 0xdd, 0xd8, 0x2a, 0xcb, 0xe3, 0xf0, 0xd9, 0x14, 0x84,
	0xfc, 0x94, 0x83, 0x48, 0x58, 0x2c, 0xd6, 0xc1, 0x6f, 0x3c, 0x7c, 0x1d, 0x5f, 0xfa, 0x78, 0xad,
	0x1e, 0xad, 0xd4, 0xc1, 0x57, 0x08, 0x3f, 0xb3, 0x0f, 0x87, 0x54, 0x48, 0xe0, 0x1f, 0x90, 0x13,
	0x10, 0x09, 0x89, 0x20, 0x78, 0xa7, 0x5d, 0xc2, 0xd0, 0xce, 0x79, 0xf6, 0x57, 0x6b, 0x6e, 0x5c,
	0xaf, 0x63, 0x5d, 0x61, 0x5e, 0x69, 0x2d, 0x71, 0xfa, 0x20, 0x22, 0x4e, 0x0f, 0xa0, 0x0a, 0x4e,
	0xce, 0xe3, 0x8f, 0x63, 0xb1, 0x6a, 0x9c, 0x2f, 0x10, 0x7e, 0xfa, 0x7d, 0x2a, 0xa4, 0xfe, 0x9f,
	0x08, 0xb6, 0x4a, 0x03, 0x4d, 0x83, 0x02, 0x79, 0xab, 0xb2, 0x4f, 0x53, 0x7c, 0x89, 0xf0, 0xa5,
	0x8f, 0x92, 0x31, 0x91, 0xa9, 0x2d, 0x29, 0x8f, 0xcb, 0x38, 0x14, 0xc7, 0xdb, 0xd5, 0x8d, 0x1a,
	0xe4, 0x6b, 0x84, 0x83, 0x3e, 0x24, 0x1c, 0x22, 0x83, 0xc5, 0x67, 0x8f, 0xb3, 0x26, 0x85, 0x73,
	0xa3, 0x96, 0x57, 0x13, 0x7d, 0x8f, 0xf0, 0xf3, 0x23, 0x49, 0xb8, 0x54, 0x9f, 0xeb, 0xed, 0xcf,
	0x21, 0x9a, 0x4a, 0xca, 0xe2, 0xe0, 0x56, 0x69, 0xb2, 0xdd, 0xa8, 0xc8, 0x6e, 0xd7, 0xf6, 0x6b,
	0xba, 0x87, 0x08, 0xbf, 0x34, 0x80, 0xbc, 0x64, 0x48, 0x85, 0x64, 0xfc, 0x34, 0xe8, 0x95, 0x2e,
	0x51, 0xe0, 0x56, 0x9c, 0xfd, 0x66, 0x21, 0x1a, 0xf6, 0x5b, 0x84, 0x9f, 0xdd, 0x63, 0x93, 0xc9,
	0x0e, 0xe3, 0x7d, 0x88, 0xa8, 0xa0, 0x2c, 0xbe, 0x4b, 0xc4, 0x71, 0x50, 0x5e, 0x21, 0x8b, 0x4b,
	0xc1, 0xdd, 0xac, 0x67, 0xd6, 0x50, 0xbf, 0x22, 0xfc, 0xf2, 0xea, 0xd7, 0x71, 0x5a, 0xd1, 0x63,
	0x27, 0xc9, 0x04, 0x24, 0x8c, 0x83, 0xbe, 0x47, 0xbb, 0x71, 0xdb, 0x15, 0xe6, 0x76, 0xc3, 0x14,
	0xcd, 0xfb, 0x13, 0xc2, 0x2f, 0x5a, 0xa4, 0x3b, 0x84, 0x4e, 0x60, 0x1c, 0x74, 0xea, 0x2c, 0xb3,
	0xf2, 0x2a, 0xd2, 0x6e, 0x93, 0x08, 0x5b, 0xad, 0x3b, 0x91, 0xa4, 0x33, 0x2a, 0x4f, 0xab, 0xd5,
	0x3a, 0xed, 0xaa, 0x5c, 0x6b, 0xd3, 0x6c, 0x3c, 0x2d, 0xfb, 0x10, 0x31, 0x3e, 0x4e, 0x0b, 0x86,
	0x40, 0xb8, 0x3c, 0x00, 0x22, 0x3d, 0x9e, 0x96, 0x02, 0xb7, 0xff, 0xd3, 0x52, 0x18, 0xa2, 0x61,
	0xff, 0x40, 0xf8, 0x72, 0x81, 0xb2, 0x7b, 0xba, 0x3b, 0x0e, 0x06, 0x4d, 0xd6, 0x5a, 0x24, 0x28,
	0xe8, 0x61, 0xf3, 0x20, 0xdb, 0x13, 0x95, 0x96, 0xd7, 0x78, 0xa2, 0xac, 0xf6, 0xca, 0x4f, 0x94,
	0x23, 0x45, 0xf3, 0xfe, 0x89, 0xf0, 0xab, 0x45, 0xd2, 0xe5, 0x4e, 0x0f, 0x1b, 0xad, 0x96, 0xde,
	0xea, 0xdd, 0xff, 0x21, 0xc9, 0xd6, 0x0d, 0xd2, 0xf2, 0xaa, 0xdd, 0x20, 0xef, 0xad, 0xdc, 0x0d,
	0x6c, 0x11, 0x1a, 0xf3, 0x37, 0x84, 0x5f, 0x71, 0xea, 0x96, 0xfb, 0xbb, 0x5d, 0x7f, 0x9d, 0xf4,
	0xe6, 0xee, 0x34, 0x8d, 0xc9, 0xf4, 0x8a, 0x7c, 0x21, 0x48, 0x1c, 0xc1, 0x62, 0x6f, 0x7b, 0xb5,
	0xca, 0xb8, 0x76, 0x57, 0xe9, 0x15, 0x05, 0x21, 0x99, 0x5e, 0xe1, 0x54, 0x7a, 0xf7, 0x8a, 0xc2,
	0x84, 0x2a, 0xbd, 0xa2, 0x24, 0x48, 0x83, 0xff, 0x8e, 0x70, 0xb8, 0xce, 0x5d, 0x29, 0xf2, 0x53,
	0x96, 0x4f, 0x49, 0x8b, 0x02, 0x14, 0xf6, 0xa0, 0x71, 0x8e, 0xa6, 0xfe, 0x01, 0xe1, 0x17, 0x46,
	0xf4, 0x30, 0x26, 0x16, 0x5c, 0x8f, 0xa1, 0xce, 0xee, 0x54, 0x9c, 0xef, 0xd5, 0x0f, 0x30, 0x5a,
	0xda, 0x5a, 0x45, 0xe5, 0x91, 0x63, 0x7c, 0x1d, 0xfa, 0x2e, 0xe4, 0x8c, 0xf0, 0x6f, 0x69, 0xe5,
	0x49, 0xc6, 0xc0, 0xbd, 0x0f, 0x02, 0x6a, 0x0d, 0xdc, 0x76, 0xa3, 0xff, 0xc0, 0xed, 0xf2, 0x6b,
	0xba, 0x9f, 0x11, 0xde, 0xb8, 0x0b, 0xfc, 0x84, 0xc6, 0x44, 0x42, 0x9e, 0xb0, 0xbc, 0x5d, 0xba,
	0xcd, 0x8a, 0xb2, 0xd7, 0x28, 0xc3, 0x20, 0x5d, 0x1c, 0xf8, 0x3e, 0x4c, 0x20, 0xce, 0xe9, 0x84,
	0x07, 0xa9, 0xdb, 0xec, 0x4f, 0x5a, 0x94, 0x61, 0x0c, 0x0c, 0x0b, 0x61, 0x6f, 0xc2, 0x04, 0x8c,
	0x2d, 0xac, 0x7d, 0xaf, 0x75, 0x5c, 0x76, 0xff, 0x81, 0xa1, 0x38, 0xc5, 0xf8, 0x84, 0x2e, 0xa4,
	0x16, 0xd2, 0x5b, 0x5e, 0x6b, 0xb8, 0x19, 0x6f, 0xd7, 0xf6, 0x1b, 0x2d, 0x75, 0x21, 0xea, 0xf0,
	0xe8, 0x88, 0xce, 0xac, 0xfb, 0xb9, 0xe3, 0xb5, 0x8a, 0x3b, 0xc0, 0xbf, 0xa5, 0x96, 0xe5, 0x98,
	0xc7, 0xec, 0x88, 0xc4, 0xb5, 0xf6, 0xd4, 0x6e, 0xac, 0x70, 0xcc, 0x76, 0xf8, 0x8d, 0x86, 0xdf,
	0x63, 0xd3, 0xd8, 0x56, 0xf2, 0xf2, 0x78, 0x87, 0xd3, 0xbf, 0xe1, 0x3b, 0x03, 0x8c, 0xe3, 0xd6,
	0x00, 0xe4, 0x08, 0x08, 0x8f, 0x8e, 0x3a, 0x52, 0x72, 0x7a, 0x30, 0x95, 0x20, 0x3c, 0x8e, 0x5b,
	0x16, 0x97, 0xff, 0x71, 0xcb, 0x6a, 0xb6, 0x0d, 0xa7, 0x77, 0xa6, 0xc0, 0x33, 0xa7, 0x00, 0xef,
	0xe1, 0x34, 0xef, 0xad, 0x3c, 0x9c, 0xda, 0x22, 0x34, 0xe6, 0x77, 0x08, 0x3f, 0xb7, 0xec, 0xfb,
	0x23, 0x49, 0xa3, 0xe3, 0xa5, 0xec, 0xce, 0x14, 0xa6, 0x10, 0xdc, 0xf4, 0xfb, 0xba, 0xc8, 0xd8,
	0x14, 0xdc, 0xbb, 0x35, 0xdd, 0x9a, 0xeb, 0x01, 0xc2, 0x4f, 0x2d, 0xc1, 0x55, 0xe5, 0x83, 0x6b,
	0xa5, 0x91, 0x86, 0x5e, 0x91, 0x6c, 0x55, 0xb5, 0x19, 0x15, 0x54, 0xb7, 0x97, 0xf9, 0x2f, 0xbb,
	0x8e, 0xf7, 0xcd, 0xa7, 0xf3, 0xbb, 0xae, 0xdb, 0x24, 0xc2, 0x7a, 0xa7, 0xfb, 0x5f, 0xf9, 0xfc,
	0xef, 0x74, 0x73, 0xb5, 0xbb, 0x5e, 0xc7, 0x6a, 0xdc, 0xe9, 0x0e, 0x40, 0xf6, 0x26, 0x53, 0x21,
	0x81, 0xef, 0xc6, 0xf7, 0x98, 0xc7, 0x9d, 0xae, 0x69, 0xf0, 0xbf, 0xd3, 0xcd, 0xfa, 0x8c, 0x9e,
	0xb5, 0x68, 0xbf, 0x9a, 0x70, 0x8f, 0x70, 0x49, 0x7d, 0x7b, 0x96, 0xc3, 0xe9, 0xdf, 0xb3, 0x9c,
	0x01, 0x0a, 0xb0, 0xfb, 0x23, 0x3a, 0x3b, 0x0f, 0x5b, 0x8f, 0xce, 0xc3, 0xd6, 0xe3, 0xf3, 0x10,
	0x3d, 0x98, 0x87, 0xe8, 0x97, 0x79, 0x88, 0xfe, 0x9a, 0x87, 0xe8, 0x6c, 0x1e, 0xa2, 0xbf, 0xe7,
	0x21, 0xfa, 0x67, 0x1e, 0xb6, 0x1e, 0xcf, 0x43, 0xf4, 0xcd, 0x45, 0xd8, 0x3a, 0xbb, 0x08, 0x5b,
	0x8f, 0x2e, 0xc2, 0x16, 0xbe, 0x42, 0x59, 0xd9, 0xe2, 0xdd, 0x27, 0xd7, 0x2f, 0x1f, 0xf6, 0x38,
	0x93, 0x6c, 0x0f, 0x7d, 0x72, 0xed, 0x30, 0xe5, 0xa1, 0xcc, 0xf1, 0x56, 0xe3, 0x46, 0xe6, 0x4f,
	0x07, 0x4f, 0x2c, 0xdf, 0x6a, 0xbc, 0xf9, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfa, 0xb5, 0xfb,
	0xe6, 0x5f, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WorkflowServiceClient is the client API for WorkflowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkflowServiceClient interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.  Namespace is a top level
	// entity within Temporal, used as a container for all resources like workflow executions, task queues, etc.  Namespace
	// acts as a sandbox and provides isolation for all resources within the namespace.  All resources belongs to exactly one
	// namespace.
	RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// UpdateNamespace is used to update the information and configuration for a registered namespace.
	UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace us used to update status of a registered namespace to DEPRECATED.  Once the namespace is deprecated
	// it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
	// deprecated namespaces.
	DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
	// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
	// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedFailure', if an instance already
	// exists with same workflowId.
	StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution.  It fails with 'NotFoundFailure' if specified workflow
	// execution in unknown to the service.
	GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error)
	// PollForDecisionTask is called by application worker to process DecisionTask from a specific task queue.  A
	// DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
	// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
	// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
	// application worker.
	PollForDecisionTask(ctx context.Context, in *PollForDecisionTaskRequest, opts ...grpc.CallOption) (*PollForDecisionTaskResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	// The response could contain a new decision task if there is one or if the request asking for one.
	RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky task queue or report any panics during DecisionTask processing.  Temporal will only append first
	// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
	RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error)
	// PollForActivityTask is called by application worker to process ActivityTask from a specific task queue.  ActivityTask
	// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
	// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
	// processing the task.
	// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
	// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
	// history before the ActivityTask is dispatched to application worker.
	PollForActivityTask(ctx context.Context, in *PollForActivityTaskRequest, opts ...grpc.CallOption) (*PollForActivityTaskResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'NotFoundFailure' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heart beating.
	RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error)
	// RecordActivityTaskHeartbeatById is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timed out and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeatById' will
	// fail with 'NotFoundFailure' in such situations.  Instead of using 'taskToken' like in RecordActivityTaskHeartbeat,
	// use Namespace, WorkflowId and ActivityId
	RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskCompletedById is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Namespace,
	// WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskFailedById is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
	// Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
	// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error)
	// RespondActivityTaskCanceledById is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
	// Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
	// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made. It fails with 'NotFoundFailure' if the workflow is not valid
	// anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
	// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
	SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.
	// If the workflow is running, this results in WorkflowExecutionSignaled event being recorded in the history
	// and a decision task being created for the execution.
	// If the workflow is not running or not found, this results in WorkflowExecutionStarted and WorkflowExecutionSignaled
	// events being recorded in history, and a decision task being created for the execution
	SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution reset an existing workflow execution to DecisionTaskCompleted event(exclusive).
	// And it will immediately terminating the current execution instance.
	ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
	// in the history and immediately terminating the execution instance.
	TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
	// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
	// API and return the query result to client as a response to 'QueryWorkflow' API call.
	RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in mutable state of a given workflow.
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	// 3. ClientLibraryVersion
	// 4. ClientFeatureVersion
	// 5. ClientImpl
	ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error)
	// QueryWorkflow returns query result for a specified workflow execution
	QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns information about the target task queue, right now this API returns the
	// pollers which polled this task queue in last few minutes.
	DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
	ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error)
}

type workflowServiceClient struct {
	cc *grpc.ClientConn
}

func NewWorkflowServiceClient(cc *grpc.ClientConn) WorkflowServiceClient {
	return &workflowServiceClient{cc}
}

func (c *workflowServiceClient) RegisterNamespace(ctx context.Context, in *RegisterNamespaceRequest, opts ...grpc.CallOption) (*RegisterNamespaceResponse, error) {
	out := new(RegisterNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeNamespace(ctx context.Context, in *DescribeNamespaceRequest, opts ...grpc.CallOption) (*DescribeNamespaceResponse, error) {
	out := new(DescribeNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListNamespaces(ctx context.Context, in *ListNamespacesRequest, opts ...grpc.CallOption) (*ListNamespacesResponse, error) {
	out := new(ListNamespacesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) UpdateNamespace(ctx context.Context, in *UpdateNamespaceRequest, opts ...grpc.CallOption) (*UpdateNamespaceResponse, error) {
	out := new(UpdateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DeprecateNamespace(ctx context.Context, in *DeprecateNamespaceRequest, opts ...grpc.CallOption) (*DeprecateNamespaceResponse, error) {
	out := new(DeprecateNamespaceResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) StartWorkflowExecution(ctx context.Context, in *StartWorkflowExecutionRequest, opts ...grpc.CallOption) (*StartWorkflowExecutionResponse, error) {
	out := new(StartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetWorkflowExecutionHistory(ctx context.Context, in *GetWorkflowExecutionHistoryRequest, opts ...grpc.CallOption) (*GetWorkflowExecutionHistoryResponse, error) {
	out := new(GetWorkflowExecutionHistoryResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollForDecisionTask(ctx context.Context, in *PollForDecisionTaskRequest, opts ...grpc.CallOption) (*PollForDecisionTaskResponse, error) {
	out := new(PollForDecisionTaskResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PollForDecisionTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondDecisionTaskCompleted(ctx context.Context, in *RespondDecisionTaskCompletedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskCompletedResponse, error) {
	out := new(RespondDecisionTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondDecisionTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondDecisionTaskFailed(ctx context.Context, in *RespondDecisionTaskFailedRequest, opts ...grpc.CallOption) (*RespondDecisionTaskFailedResponse, error) {
	out := new(RespondDecisionTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondDecisionTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) PollForActivityTask(ctx context.Context, in *PollForActivityTaskRequest, opts ...grpc.CallOption) (*PollForActivityTaskResponse, error) {
	out := new(PollForActivityTaskResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/PollForActivityTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeat(ctx context.Context, in *RecordActivityTaskHeartbeatRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatResponse, error) {
	out := new(RecordActivityTaskHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RecordActivityTaskHeartbeatById(ctx context.Context, in *RecordActivityTaskHeartbeatByIdRequest, opts ...grpc.CallOption) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	out := new(RecordActivityTaskHeartbeatByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompleted(ctx context.Context, in *RespondActivityTaskCompletedRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedResponse, error) {
	out := new(RespondActivityTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCompletedById(ctx context.Context, in *RespondActivityTaskCompletedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCompletedByIdResponse, error) {
	out := new(RespondActivityTaskCompletedByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailed(ctx context.Context, in *RespondActivityTaskFailedRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedResponse, error) {
	out := new(RespondActivityTaskFailedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskFailedById(ctx context.Context, in *RespondActivityTaskFailedByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskFailedByIdResponse, error) {
	out := new(RespondActivityTaskFailedByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceled(ctx context.Context, in *RespondActivityTaskCanceledRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledResponse, error) {
	out := new(RespondActivityTaskCanceledResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondActivityTaskCanceledById(ctx context.Context, in *RespondActivityTaskCanceledByIdRequest, opts ...grpc.CallOption) (*RespondActivityTaskCanceledByIdResponse, error) {
	out := new(RespondActivityTaskCanceledByIdResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RequestCancelWorkflowExecution(ctx context.Context, in *RequestCancelWorkflowExecutionRequest, opts ...grpc.CallOption) (*RequestCancelWorkflowExecutionResponse, error) {
	out := new(RequestCancelWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWorkflowExecution(ctx context.Context, in *SignalWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWorkflowExecutionResponse, error) {
	out := new(SignalWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) SignalWithStartWorkflowExecution(ctx context.Context, in *SignalWithStartWorkflowExecutionRequest, opts ...grpc.CallOption) (*SignalWithStartWorkflowExecutionResponse, error) {
	out := new(SignalWithStartWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetWorkflowExecution(ctx context.Context, in *ResetWorkflowExecutionRequest, opts ...grpc.CallOption) (*ResetWorkflowExecutionResponse, error) {
	out := new(ResetWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) TerminateWorkflowExecution(ctx context.Context, in *TerminateWorkflowExecutionRequest, opts ...grpc.CallOption) (*TerminateWorkflowExecutionResponse, error) {
	out := new(TerminateWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListOpenWorkflowExecutions(ctx context.Context, in *ListOpenWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListOpenWorkflowExecutionsResponse, error) {
	out := new(ListOpenWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListClosedWorkflowExecutions(ctx context.Context, in *ListClosedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListClosedWorkflowExecutionsResponse, error) {
	out := new(ListClosedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error) {
	out := new(ListWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListArchivedWorkflowExecutions(ctx context.Context, in *ListArchivedWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListArchivedWorkflowExecutionsResponse, error) {
	out := new(ListArchivedWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ScanWorkflowExecutions(ctx context.Context, in *ScanWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ScanWorkflowExecutionsResponse, error) {
	out := new(ScanWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) CountWorkflowExecutions(ctx context.Context, in *CountWorkflowExecutionsRequest, opts ...grpc.CallOption) (*CountWorkflowExecutionsResponse, error) {
	out := new(CountWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetSearchAttributes(ctx context.Context, in *GetSearchAttributesRequest, opts ...grpc.CallOption) (*GetSearchAttributesResponse, error) {
	out := new(GetSearchAttributesResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) RespondQueryTaskCompleted(ctx context.Context, in *RespondQueryTaskCompletedRequest, opts ...grpc.CallOption) (*RespondQueryTaskCompletedResponse, error) {
	out := new(RespondQueryTaskCompletedResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ResetStickyTaskQueue(ctx context.Context, in *ResetStickyTaskQueueRequest, opts ...grpc.CallOption) (*ResetStickyTaskQueueResponse, error) {
	out := new(ResetStickyTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) QueryWorkflow(ctx context.Context, in *QueryWorkflowRequest, opts ...grpc.CallOption) (*QueryWorkflowResponse, error) {
	out := new(QueryWorkflowResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeWorkflowExecution(ctx context.Context, in *DescribeWorkflowExecutionRequest, opts ...grpc.CallOption) (*DescribeWorkflowExecutionResponse, error) {
	out := new(DescribeWorkflowExecutionResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) DescribeTaskQueue(ctx context.Context, in *DescribeTaskQueueRequest, opts ...grpc.CallOption) (*DescribeTaskQueueResponse, error) {
	out := new(DescribeTaskQueueResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowServiceClient) ListTaskQueuePartitions(ctx context.Context, in *ListTaskQueuePartitionsRequest, opts ...grpc.CallOption) (*ListTaskQueuePartitionsResponse, error) {
	out := new(ListTaskQueuePartitionsResponse)
	err := c.cc.Invoke(ctx, "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowServiceServer is the server API for WorkflowService service.
type WorkflowServiceServer interface {
	// RegisterNamespace creates a new namespace which can be used as a container for all resources.  Namespace is a top level
	// entity within Temporal, used as a container for all resources like workflow executions, task queues, etc.  Namespace
	// acts as a sandbox and provides isolation for all resources within the namespace.  All resources belongs to exactly one
	// namespace.
	RegisterNamespace(context.Context, *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error)
	// DescribeNamespace returns the information and configuration for a registered namespace.
	DescribeNamespace(context.Context, *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error)
	// ListNamespaces returns the information and configuration for all namespaces.
	ListNamespaces(context.Context, *ListNamespacesRequest) (*ListNamespacesResponse, error)
	// (-- api-linter: core::0134::method-signature=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// (-- api-linter: core::0134::response-message-name=disabled
	//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
	// UpdateNamespace is used to update the information and configuration for a registered namespace.
	UpdateNamespace(context.Context, *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error)
	// DeprecateNamespace us used to update status of a registered namespace to DEPRECATED.  Once the namespace is deprecated
	// it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
	// deprecated namespaces.
	DeprecateNamespace(context.Context, *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error)
	// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
	// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
	// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedFailure', if an instance already
	// exists with same workflowId.
	StartWorkflowExecution(context.Context, *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error)
	// GetWorkflowExecutionHistory returns the history of specified workflow execution.  It fails with 'NotFoundFailure' if specified workflow
	// execution in unknown to the service.
	GetWorkflowExecutionHistory(context.Context, *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error)
	// PollForDecisionTask is called by application worker to process DecisionTask from a specific task queue.  A
	// DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
	// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
	// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
	// application worker.
	PollForDecisionTask(context.Context, *PollForDecisionTaskRequest) (*PollForDecisionTaskResponse, error)
	// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
	// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
	// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
	// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
	// for completing the DecisionTask.
	// The response could contain a new decision task if there is one or if the request asking for one.
	RespondDecisionTaskCompleted(context.Context, *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error)
	// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
	// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
	// either clear sticky task queue or report any panics during DecisionTask processing.  Temporal will only append first
	// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
	RespondDecisionTaskFailed(context.Context, *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error)
	// PollForActivityTask is called by application worker to process ActivityTask from a specific task queue.  ActivityTask
	// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
	// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
	// processing the task.
	// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
	// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
	// history before the ActivityTask is dispatched to application worker.
	PollForActivityTask(context.Context, *PollForActivityTaskRequest) (*PollForActivityTaskResponse, error)
	// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
	// fail with 'NotFoundFailure' in such situations.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for heart beating.
	RecordActivityTaskHeartbeat(context.Context, *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error)
	// RecordActivityTaskHeartbeatById is called by application worker while it is processing an ActivityTask.  If worker fails
	// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timed out and
	// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeatById' will
	// fail with 'NotFoundFailure' in such situations.  Instead of using 'taskToken' like in RecordActivityTaskHeartbeat,
	// use Namespace, WorkflowId and ActivityId
	RecordActivityTaskHeartbeatById(context.Context, *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error)
	// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCompleted(context.Context, *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error)
	// RespondActivityTaskCompletedById is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
	// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Namespace,
	// WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskCompletedById(context.Context, *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error)
	// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
	// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskFailed(context.Context, *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error)
	// RespondActivityTaskFailedById is called by application worker when it is done processing an ActivityTask.
	// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
	// Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskFailedById(context.Context, *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error)
	// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
	// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
	// PollForActivityTask API call for completion. It fails with 'NotFoundFailure' if the taskToken is not valid
	// anymore due to activity timeout.
	RespondActivityTaskCanceled(context.Context, *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error)
	// RespondActivityTaskCanceledById is called by application worker when it is successfully canceled an ActivityTask.
	// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
	// Namespace, WorkflowId and ActivityId instead of 'taskToken' for completion. It fails with 'NotFoundFailure'
	// if the these Ids are not valid anymore due to activity timeout.
	RespondActivityTaskCanceledById(context.Context, *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error)
	// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
	// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
	// created for the workflow instance so new decisions could be made. It fails with 'NotFoundFailure' if the workflow is not valid
	// anymore due to completion or doesn't exist.
	RequestCancelWorkflowExecution(context.Context, *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error)
	// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
	// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
	SignalWorkflowExecution(context.Context, *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error)
	// SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.
	// If the workflow is running, this results in WorkflowExecutionSignaled event being recorded in the history
	// and a decision task being created for the execution.
	// If the workflow is not running or not found, this results in WorkflowExecutionStarted and WorkflowExecutionSignaled
	// events being recorded in history, and a decision task being created for the execution
	SignalWithStartWorkflowExecution(context.Context, *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error)
	// ResetWorkflowExecution reset an existing workflow execution to DecisionTaskCompleted event(exclusive).
	// And it will immediately terminating the current execution instance.
	ResetWorkflowExecution(context.Context, *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error)
	// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
	// in the history and immediately terminating the execution instance.
	TerminateWorkflowExecution(context.Context, *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error)
	// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
	ListOpenWorkflowExecutions(context.Context, *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error)
	// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
	ListClosedWorkflowExecutions(context.Context, *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error)
	// ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
	ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error)
	// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
	ListArchivedWorkflowExecutions(context.Context, *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error)
	// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
	ScanWorkflowExecutions(context.Context, *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error)
	// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
	CountWorkflowExecutions(context.Context, *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error)
	// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
	GetSearchAttributes(context.Context, *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error)
	// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
	// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
	// API and return the query result to client as a response to 'QueryWorkflow' API call.
	RespondQueryTaskCompleted(context.Context, *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error)
	// ResetStickyTaskQueue resets the sticky task queue related information in mutable state of a given workflow.
	// Things cleared are:
	// 1. StickyTaskQueue
	// 2. StickyScheduleToStartTimeout
	// 3. ClientLibraryVersion
	// 4. ClientFeatureVersion
	// 5. ClientImpl
	ResetStickyTaskQueue(context.Context, *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error)
	// QueryWorkflow returns query result for a specified workflow execution
	QueryWorkflow(context.Context, *QueryWorkflowRequest) (*QueryWorkflowResponse, error)
	// DescribeWorkflowExecution returns information about the specified workflow execution.
	DescribeWorkflowExecution(context.Context, *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error)
	// DescribeTaskQueue returns information about the target task queue, right now this API returns the
	// pollers which polled this task queue in last few minutes.
	DescribeTaskQueue(context.Context, *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error)
	// GetClusterInfo returns information about temporal cluster
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
	ListTaskQueuePartitions(context.Context, *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error)
}

// UnimplementedWorkflowServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWorkflowServiceServer struct {
}

func (*UnimplementedWorkflowServiceServer) RegisterNamespace(ctx context.Context, req *RegisterNamespaceRequest) (*RegisterNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeNamespace(ctx context.Context, req *DescribeNamespaceRequest) (*DescribeNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListNamespaces(ctx context.Context, req *ListNamespacesRequest) (*ListNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (*UnimplementedWorkflowServiceServer) UpdateNamespace(ctx context.Context, req *UpdateNamespaceRequest) (*UpdateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) DeprecateNamespace(ctx context.Context, req *DeprecateNamespaceRequest) (*DeprecateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeprecateNamespace not implemented")
}
func (*UnimplementedWorkflowServiceServer) StartWorkflowExecution(ctx context.Context, req *StartWorkflowExecutionRequest) (*StartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetWorkflowExecutionHistory(ctx context.Context, req *GetWorkflowExecutionHistoryRequest) (*GetWorkflowExecutionHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowExecutionHistory not implemented")
}
func (*UnimplementedWorkflowServiceServer) PollForDecisionTask(ctx context.Context, req *PollForDecisionTaskRequest) (*PollForDecisionTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollForDecisionTask not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondDecisionTaskCompleted(ctx context.Context, req *RespondDecisionTaskCompletedRequest) (*RespondDecisionTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondDecisionTaskFailed(ctx context.Context, req *RespondDecisionTaskFailedRequest) (*RespondDecisionTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondDecisionTaskFailed not implemented")
}
func (*UnimplementedWorkflowServiceServer) PollForActivityTask(ctx context.Context, req *PollForActivityTaskRequest) (*PollForActivityTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollForActivityTask not implemented")
}
func (*UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeat(ctx context.Context, req *RecordActivityTaskHeartbeatRequest) (*RecordActivityTaskHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeat not implemented")
}
func (*UnimplementedWorkflowServiceServer) RecordActivityTaskHeartbeatById(ctx context.Context, req *RecordActivityTaskHeartbeatByIdRequest) (*RecordActivityTaskHeartbeatByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordActivityTaskHeartbeatById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCompleted(ctx context.Context, req *RespondActivityTaskCompletedRequest) (*RespondActivityTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCompletedById(ctx context.Context, req *RespondActivityTaskCompletedByIdRequest) (*RespondActivityTaskCompletedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCompletedById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskFailed(ctx context.Context, req *RespondActivityTaskFailedRequest) (*RespondActivityTaskFailedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailed not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskFailedById(ctx context.Context, req *RespondActivityTaskFailedByIdRequest) (*RespondActivityTaskFailedByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskFailedById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCanceled(ctx context.Context, req *RespondActivityTaskCanceledRequest) (*RespondActivityTaskCanceledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceled not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondActivityTaskCanceledById(ctx context.Context, req *RespondActivityTaskCanceledByIdRequest) (*RespondActivityTaskCanceledByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondActivityTaskCanceledById not implemented")
}
func (*UnimplementedWorkflowServiceServer) RequestCancelWorkflowExecution(ctx context.Context, req *RequestCancelWorkflowExecutionRequest) (*RequestCancelWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCancelWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) SignalWorkflowExecution(ctx context.Context, req *SignalWorkflowExecutionRequest) (*SignalWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) SignalWithStartWorkflowExecution(ctx context.Context, req *SignalWithStartWorkflowExecutionRequest) (*SignalWithStartWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalWithStartWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) ResetWorkflowExecution(ctx context.Context, req *ResetWorkflowExecutionRequest) (*ResetWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) TerminateWorkflowExecution(ctx context.Context, req *TerminateWorkflowExecutionRequest) (*TerminateWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListOpenWorkflowExecutions(ctx context.Context, req *ListOpenWorkflowExecutionsRequest) (*ListOpenWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOpenWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListClosedWorkflowExecutions(ctx context.Context, req *ListClosedWorkflowExecutionsRequest) (*ListClosedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClosedWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListWorkflowExecutions(ctx context.Context, req *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListArchivedWorkflowExecutions(ctx context.Context, req *ListArchivedWorkflowExecutionsRequest) (*ListArchivedWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArchivedWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) ScanWorkflowExecutions(ctx context.Context, req *ScanWorkflowExecutionsRequest) (*ScanWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) CountWorkflowExecutions(ctx context.Context, req *CountWorkflowExecutionsRequest) (*CountWorkflowExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountWorkflowExecutions not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetSearchAttributes(ctx context.Context, req *GetSearchAttributesRequest) (*GetSearchAttributesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSearchAttributes not implemented")
}
func (*UnimplementedWorkflowServiceServer) RespondQueryTaskCompleted(ctx context.Context, req *RespondQueryTaskCompletedRequest) (*RespondQueryTaskCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RespondQueryTaskCompleted not implemented")
}
func (*UnimplementedWorkflowServiceServer) ResetStickyTaskQueue(ctx context.Context, req *ResetStickyTaskQueueRequest) (*ResetStickyTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetStickyTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) QueryWorkflow(ctx context.Context, req *QueryWorkflowRequest) (*QueryWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWorkflow not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeWorkflowExecution(ctx context.Context, req *DescribeWorkflowExecutionRequest) (*DescribeWorkflowExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkflowExecution not implemented")
}
func (*UnimplementedWorkflowServiceServer) DescribeTaskQueue(ctx context.Context, req *DescribeTaskQueueRequest) (*DescribeTaskQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTaskQueue not implemented")
}
func (*UnimplementedWorkflowServiceServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (*UnimplementedWorkflowServiceServer) ListTaskQueuePartitions(ctx context.Context, req *ListTaskQueuePartitionsRequest) (*ListTaskQueuePartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTaskQueuePartitions not implemented")
}

func RegisterWorkflowServiceServer(s *grpc.Server, srv WorkflowServiceServer) {
	s.RegisterService(&_WorkflowService_serviceDesc, srv)
}

func _WorkflowService_RegisterNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RegisterNamespace(ctx, req.(*RegisterNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeNamespace(ctx, req.(*DescribeNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListNamespaces(ctx, req.(*ListNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_UpdateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).UpdateNamespace(ctx, req.(*UpdateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DeprecateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprecateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DeprecateNamespace(ctx, req.(*DeprecateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_StartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).StartWorkflowExecution(ctx, req.(*StartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetWorkflowExecutionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetWorkflowExecutionHistory(ctx, req.(*GetWorkflowExecutionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollForDecisionTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollForDecisionTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollForDecisionTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PollForDecisionTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollForDecisionTask(ctx, req.(*PollForDecisionTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondDecisionTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondDecisionTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondDecisionTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondDecisionTaskCompleted(ctx, req.(*RespondDecisionTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondDecisionTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondDecisionTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondDecisionTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondDecisionTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondDecisionTaskFailed(ctx, req.(*RespondDecisionTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_PollForActivityTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollForActivityTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).PollForActivityTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/PollForActivityTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).PollForActivityTask(ctx, req.(*PollForActivityTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeat(ctx, req.(*RecordActivityTaskHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RecordActivityTaskHeartbeatById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordActivityTaskHeartbeatByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RecordActivityTaskHeartbeatById(ctx, req.(*RecordActivityTaskHeartbeatByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompleted(ctx, req.(*RespondActivityTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCompletedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCompletedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCompletedById(ctx, req.(*RespondActivityTaskCompletedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailed(ctx, req.(*RespondActivityTaskFailedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskFailedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskFailedByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskFailedById(ctx, req.(*RespondActivityTaskFailedByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceled(ctx, req.(*RespondActivityTaskCanceledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondActivityTaskCanceledById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondActivityTaskCanceledByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondActivityTaskCanceledById(ctx, req.(*RespondActivityTaskCanceledByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RequestCancelWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCancelWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RequestCancelWorkflowExecution(ctx, req.(*RequestCancelWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWorkflowExecution(ctx, req.(*SignalWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_SignalWithStartWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalWithStartWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).SignalWithStartWorkflowExecution(ctx, req.(*SignalWithStartWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetWorkflowExecution(ctx, req.(*ResetWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_TerminateWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).TerminateWorkflowExecution(ctx, req.(*TerminateWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListOpenWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOpenWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListOpenWorkflowExecutions(ctx, req.(*ListOpenWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListClosedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClosedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListClosedWorkflowExecutions(ctx, req.(*ListClosedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListWorkflowExecutions(ctx, req.(*ListWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListArchivedWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArchivedWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListArchivedWorkflowExecutions(ctx, req.(*ListArchivedWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ScanWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ScanWorkflowExecutions(ctx, req.(*ScanWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_CountWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).CountWorkflowExecutions(ctx, req.(*CountWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetSearchAttributes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSearchAttributesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetSearchAttributes(ctx, req.(*GetSearchAttributesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_RespondQueryTaskCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondQueryTaskCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).RespondQueryTaskCompleted(ctx, req.(*RespondQueryTaskCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ResetStickyTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStickyTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ResetStickyTaskQueue(ctx, req.(*ResetStickyTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_QueryWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).QueryWorkflow(ctx, req.(*QueryWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeWorkflowExecution(ctx, req.(*DescribeWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_DescribeTaskQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTaskQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).DescribeTaskQueue(ctx, req.(*DescribeTaskQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowService_ListTaskQueuePartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTaskQueuePartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowServiceServer).ListTaskQueuePartitions(ctx, req.(*ListTaskQueuePartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkflowService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "temporal.api.workflowservice.v1.WorkflowService",
	HandlerType: (*WorkflowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNamespace",
			Handler:    _WorkflowService_RegisterNamespace_Handler,
		},
		{
			MethodName: "DescribeNamespace",
			Handler:    _WorkflowService_DescribeNamespace_Handler,
		},
		{
			MethodName: "ListNamespaces",
			Handler:    _WorkflowService_ListNamespaces_Handler,
		},
		{
			MethodName: "UpdateNamespace",
			Handler:    _WorkflowService_UpdateNamespace_Handler,
		},
		{
			MethodName: "DeprecateNamespace",
			Handler:    _WorkflowService_DeprecateNamespace_Handler,
		},
		{
			MethodName: "StartWorkflowExecution",
			Handler:    _WorkflowService_StartWorkflowExecution_Handler,
		},
		{
			MethodName: "GetWorkflowExecutionHistory",
			Handler:    _WorkflowService_GetWorkflowExecutionHistory_Handler,
		},
		{
			MethodName: "PollForDecisionTask",
			Handler:    _WorkflowService_PollForDecisionTask_Handler,
		},
		{
			MethodName: "RespondDecisionTaskCompleted",
			Handler:    _WorkflowService_RespondDecisionTaskCompleted_Handler,
		},
		{
			MethodName: "RespondDecisionTaskFailed",
			Handler:    _WorkflowService_RespondDecisionTaskFailed_Handler,
		},
		{
			MethodName: "PollForActivityTask",
			Handler:    _WorkflowService_PollForActivityTask_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeat",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeat_Handler,
		},
		{
			MethodName: "RecordActivityTaskHeartbeatById",
			Handler:    _WorkflowService_RecordActivityTaskHeartbeatById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompleted",
			Handler:    _WorkflowService_RespondActivityTaskCompleted_Handler,
		},
		{
			MethodName: "RespondActivityTaskCompletedById",
			Handler:    _WorkflowService_RespondActivityTaskCompletedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailed",
			Handler:    _WorkflowService_RespondActivityTaskFailed_Handler,
		},
		{
			MethodName: "RespondActivityTaskFailedById",
			Handler:    _WorkflowService_RespondActivityTaskFailedById_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceled",
			Handler:    _WorkflowService_RespondActivityTaskCanceled_Handler,
		},
		{
			MethodName: "RespondActivityTaskCanceledById",
			Handler:    _WorkflowService_RespondActivityTaskCanceledById_Handler,
		},
		{
			MethodName: "RequestCancelWorkflowExecution",
			Handler:    _WorkflowService_RequestCancelWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWorkflowExecution",
			Handler:    _WorkflowService_SignalWorkflowExecution_Handler,
		},
		{
			MethodName: "SignalWithStartWorkflowExecution",
			Handler:    _WorkflowService_SignalWithStartWorkflowExecution_Handler,
		},
		{
			MethodName: "ResetWorkflowExecution",
			Handler:    _WorkflowService_ResetWorkflowExecution_Handler,
		},
		{
			MethodName: "TerminateWorkflowExecution",
			Handler:    _WorkflowService_TerminateWorkflowExecution_Handler,
		},
		{
			MethodName: "ListOpenWorkflowExecutions",
			Handler:    _WorkflowService_ListOpenWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListClosedWorkflowExecutions",
			Handler:    _WorkflowService_ListClosedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListWorkflowExecutions",
			Handler:    _WorkflowService_ListWorkflowExecutions_Handler,
		},
		{
			MethodName: "ListArchivedWorkflowExecutions",
			Handler:    _WorkflowService_ListArchivedWorkflowExecutions_Handler,
		},
		{
			MethodName: "ScanWorkflowExecutions",
			Handler:    _WorkflowService_ScanWorkflowExecutions_Handler,
		},
		{
			MethodName: "CountWorkflowExecutions",
			Handler:    _WorkflowService_CountWorkflowExecutions_Handler,
		},
		{
			MethodName: "GetSearchAttributes",
			Handler:    _WorkflowService_GetSearchAttributes_Handler,
		},
		{
			MethodName: "RespondQueryTaskCompleted",
			Handler:    _WorkflowService_RespondQueryTaskCompleted_Handler,
		},
		{
			MethodName: "ResetStickyTaskQueue",
			Handler:    _WorkflowService_ResetStickyTaskQueue_Handler,
		},
		{
			MethodName: "QueryWorkflow",
			Handler:    _WorkflowService_QueryWorkflow_Handler,
		},
		{
			MethodName: "DescribeWorkflowExecution",
			Handler:    _WorkflowService_DescribeWorkflowExecution_Handler,
		},
		{
			MethodName: "DescribeTaskQueue",
			Handler:    _WorkflowService_DescribeTaskQueue_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _WorkflowService_GetClusterInfo_Handler,
		},
		{
			MethodName: "ListTaskQueuePartitions",
			Handler:    _WorkflowService_ListTaskQueuePartitions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "temporal/api/workflowservice/v1/service.proto",
}
