// Code generated by protoc-gen-go. DO NOT EDIT.
// plugins:
// 	protoc-gen-go
// 	protoc
// source: temporal/api/failure/v1/message.proto

//go:build !protoopaque

package failure

import (
	reflect "reflect"
	"strconv"
	unsafe "unsafe"

	v1 "go.temporal.io/api/common/v1"
	v11 "go.temporal.io/api/enums/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ApplicationFailureInfo struct {
	state        protoimpl.MessageState `protogen:"hybrid.v1"`
	Type         string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	NonRetryable bool                   `protobuf:"varint,2,opt,name=non_retryable,json=nonRetryable,proto3" json:"non_retryable,omitempty"`
	Details      *v1.Payloads           `protobuf:"bytes,3,opt,name=details,proto3" json:"details,omitempty"`
	// next_retry_delay can be used by the client to override the activity
	// retry interval calculated by the retry policy. Retry attempts will
	// still be subject to the maximum retries limit and total time limit
	// defined by the policy.
	NextRetryDelay *durationpb.Duration         `protobuf:"bytes,4,opt,name=next_retry_delay,json=nextRetryDelay,proto3" json:"next_retry_delay,omitempty"`
	Category       v11.ApplicationErrorCategory `protobuf:"varint,5,opt,name=category,proto3,enum=temporal.api.enums.v1.ApplicationErrorCategory" json:"category,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ApplicationFailureInfo) Reset() {
	*x = ApplicationFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplicationFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplicationFailureInfo) ProtoMessage() {}

func (x *ApplicationFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ApplicationFailureInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ApplicationFailureInfo) GetNonRetryable() bool {
	if x != nil {
		return x.NonRetryable
	}
	return false
}

func (x *ApplicationFailureInfo) GetDetails() *v1.Payloads {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *ApplicationFailureInfo) GetNextRetryDelay() *durationpb.Duration {
	if x != nil {
		return x.NextRetryDelay
	}
	return nil
}

func (x *ApplicationFailureInfo) GetCategory() v11.ApplicationErrorCategory {
	if x != nil {
		return x.Category
	}
	return v11.ApplicationErrorCategory(0)
}

func (x *ApplicationFailureInfo) SetType(v string) {
	x.Type = v
}

func (x *ApplicationFailureInfo) SetNonRetryable(v bool) {
	x.NonRetryable = v
}

func (x *ApplicationFailureInfo) SetDetails(v *v1.Payloads) {
	x.Details = v
}

func (x *ApplicationFailureInfo) SetNextRetryDelay(v *durationpb.Duration) {
	x.NextRetryDelay = v
}

func (x *ApplicationFailureInfo) SetCategory(v v11.ApplicationErrorCategory) {
	x.Category = v
}

func (x *ApplicationFailureInfo) HasDetails() bool {
	if x == nil {
		return false
	}
	return x.Details != nil
}

func (x *ApplicationFailureInfo) HasNextRetryDelay() bool {
	if x == nil {
		return false
	}
	return x.NextRetryDelay != nil
}

func (x *ApplicationFailureInfo) ClearDetails() {
	x.Details = nil
}

func (x *ApplicationFailureInfo) ClearNextRetryDelay() {
	x.NextRetryDelay = nil
}

type ApplicationFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Type         string
	NonRetryable bool
	Details      *v1.Payloads
	// next_retry_delay can be used by the client to override the activity
	// retry interval calculated by the retry policy. Retry attempts will
	// still be subject to the maximum retries limit and total time limit
	// defined by the policy.
	NextRetryDelay *durationpb.Duration
	Category       v11.ApplicationErrorCategory
}

func (b0 ApplicationFailureInfo_builder) Build() *ApplicationFailureInfo {
	m0 := &ApplicationFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.Type = b.Type
	x.NonRetryable = b.NonRetryable
	x.Details = b.Details
	x.NextRetryDelay = b.NextRetryDelay
	x.Category = b.Category
	return m0
}

type TimeoutFailureInfo struct {
	state                protoimpl.MessageState `protogen:"hybrid.v1"`
	TimeoutType          v11.TimeoutType        `protobuf:"varint,1,opt,name=timeout_type,json=timeoutType,proto3,enum=temporal.api.enums.v1.TimeoutType" json:"timeout_type,omitempty"`
	LastHeartbeatDetails *v1.Payloads           `protobuf:"bytes,2,opt,name=last_heartbeat_details,json=lastHeartbeatDetails,proto3" json:"last_heartbeat_details,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TimeoutFailureInfo) Reset() {
	*x = TimeoutFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeoutFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeoutFailureInfo) ProtoMessage() {}

func (x *TimeoutFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *TimeoutFailureInfo) GetTimeoutType() v11.TimeoutType {
	if x != nil {
		return x.TimeoutType
	}
	return v11.TimeoutType(0)
}

func (x *TimeoutFailureInfo) GetLastHeartbeatDetails() *v1.Payloads {
	if x != nil {
		return x.LastHeartbeatDetails
	}
	return nil
}

func (x *TimeoutFailureInfo) SetTimeoutType(v v11.TimeoutType) {
	x.TimeoutType = v
}

func (x *TimeoutFailureInfo) SetLastHeartbeatDetails(v *v1.Payloads) {
	x.LastHeartbeatDetails = v
}

func (x *TimeoutFailureInfo) HasLastHeartbeatDetails() bool {
	if x == nil {
		return false
	}
	return x.LastHeartbeatDetails != nil
}

func (x *TimeoutFailureInfo) ClearLastHeartbeatDetails() {
	x.LastHeartbeatDetails = nil
}

type TimeoutFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	TimeoutType          v11.TimeoutType
	LastHeartbeatDetails *v1.Payloads
}

func (b0 TimeoutFailureInfo_builder) Build() *TimeoutFailureInfo {
	m0 := &TimeoutFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.TimeoutType = b.TimeoutType
	x.LastHeartbeatDetails = b.LastHeartbeatDetails
	return m0
}

type CanceledFailureInfo struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	Details       *v1.Payloads           `protobuf:"bytes,1,opt,name=details,proto3" json:"details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CanceledFailureInfo) Reset() {
	*x = CanceledFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CanceledFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CanceledFailureInfo) ProtoMessage() {}

func (x *CanceledFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *CanceledFailureInfo) GetDetails() *v1.Payloads {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *CanceledFailureInfo) SetDetails(v *v1.Payloads) {
	x.Details = v
}

func (x *CanceledFailureInfo) HasDetails() bool {
	if x == nil {
		return false
	}
	return x.Details != nil
}

func (x *CanceledFailureInfo) ClearDetails() {
	x.Details = nil
}

type CanceledFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Details *v1.Payloads
}

func (b0 CanceledFailureInfo_builder) Build() *CanceledFailureInfo {
	m0 := &CanceledFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.Details = b.Details
	return m0
}

type TerminatedFailureInfo struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TerminatedFailureInfo) Reset() {
	*x = TerminatedFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TerminatedFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TerminatedFailureInfo) ProtoMessage() {}

func (x *TerminatedFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type TerminatedFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 TerminatedFailureInfo_builder) Build() *TerminatedFailureInfo {
	m0 := &TerminatedFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

type ServerFailureInfo struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	NonRetryable  bool                   `protobuf:"varint,1,opt,name=non_retryable,json=nonRetryable,proto3" json:"non_retryable,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerFailureInfo) Reset() {
	*x = ServerFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerFailureInfo) ProtoMessage() {}

func (x *ServerFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ServerFailureInfo) GetNonRetryable() bool {
	if x != nil {
		return x.NonRetryable
	}
	return false
}

func (x *ServerFailureInfo) SetNonRetryable(v bool) {
	x.NonRetryable = v
}

type ServerFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	NonRetryable bool
}

func (b0 ServerFailureInfo_builder) Build() *ServerFailureInfo {
	m0 := &ServerFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.NonRetryable = b.NonRetryable
	return m0
}

type ResetWorkflowFailureInfo struct {
	state                protoimpl.MessageState `protogen:"hybrid.v1"`
	LastHeartbeatDetails *v1.Payloads           `protobuf:"bytes,1,opt,name=last_heartbeat_details,json=lastHeartbeatDetails,proto3" json:"last_heartbeat_details,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ResetWorkflowFailureInfo) Reset() {
	*x = ResetWorkflowFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResetWorkflowFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResetWorkflowFailureInfo) ProtoMessage() {}

func (x *ResetWorkflowFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ResetWorkflowFailureInfo) GetLastHeartbeatDetails() *v1.Payloads {
	if x != nil {
		return x.LastHeartbeatDetails
	}
	return nil
}

func (x *ResetWorkflowFailureInfo) SetLastHeartbeatDetails(v *v1.Payloads) {
	x.LastHeartbeatDetails = v
}

func (x *ResetWorkflowFailureInfo) HasLastHeartbeatDetails() bool {
	if x == nil {
		return false
	}
	return x.LastHeartbeatDetails != nil
}

func (x *ResetWorkflowFailureInfo) ClearLastHeartbeatDetails() {
	x.LastHeartbeatDetails = nil
}

type ResetWorkflowFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	LastHeartbeatDetails *v1.Payloads
}

func (b0 ResetWorkflowFailureInfo_builder) Build() *ResetWorkflowFailureInfo {
	m0 := &ResetWorkflowFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.LastHeartbeatDetails = b.LastHeartbeatDetails
	return m0
}

type ActivityFailureInfo struct {
	state            protoimpl.MessageState `protogen:"hybrid.v1"`
	ScheduledEventId int64                  `protobuf:"varint,1,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	StartedEventId   int64                  `protobuf:"varint,2,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	Identity         string                 `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	ActivityType     *v1.ActivityType       `protobuf:"bytes,4,opt,name=activity_type,json=activityType,proto3" json:"activity_type,omitempty"`
	ActivityId       string                 `protobuf:"bytes,5,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	RetryState       v11.RetryState         `protobuf:"varint,6,opt,name=retry_state,json=retryState,proto3,enum=temporal.api.enums.v1.RetryState" json:"retry_state,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ActivityFailureInfo) Reset() {
	*x = ActivityFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActivityFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActivityFailureInfo) ProtoMessage() {}

func (x *ActivityFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ActivityFailureInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *ActivityFailureInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ActivityFailureInfo) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *ActivityFailureInfo) GetActivityType() *v1.ActivityType {
	if x != nil {
		return x.ActivityType
	}
	return nil
}

func (x *ActivityFailureInfo) GetActivityId() string {
	if x != nil {
		return x.ActivityId
	}
	return ""
}

func (x *ActivityFailureInfo) GetRetryState() v11.RetryState {
	if x != nil {
		return x.RetryState
	}
	return v11.RetryState(0)
}

func (x *ActivityFailureInfo) SetScheduledEventId(v int64) {
	x.ScheduledEventId = v
}

func (x *ActivityFailureInfo) SetStartedEventId(v int64) {
	x.StartedEventId = v
}

func (x *ActivityFailureInfo) SetIdentity(v string) {
	x.Identity = v
}

func (x *ActivityFailureInfo) SetActivityType(v *v1.ActivityType) {
	x.ActivityType = v
}

func (x *ActivityFailureInfo) SetActivityId(v string) {
	x.ActivityId = v
}

func (x *ActivityFailureInfo) SetRetryState(v v11.RetryState) {
	x.RetryState = v
}

func (x *ActivityFailureInfo) HasActivityType() bool {
	if x == nil {
		return false
	}
	return x.ActivityType != nil
}

func (x *ActivityFailureInfo) ClearActivityType() {
	x.ActivityType = nil
}

type ActivityFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	ScheduledEventId int64
	StartedEventId   int64
	Identity         string
	ActivityType     *v1.ActivityType
	ActivityId       string
	RetryState       v11.RetryState
}

func (b0 ActivityFailureInfo_builder) Build() *ActivityFailureInfo {
	m0 := &ActivityFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.ScheduledEventId = b.ScheduledEventId
	x.StartedEventId = b.StartedEventId
	x.Identity = b.Identity
	x.ActivityType = b.ActivityType
	x.ActivityId = b.ActivityId
	x.RetryState = b.RetryState
	return m0
}

type ChildWorkflowExecutionFailureInfo struct {
	state             protoimpl.MessageState `protogen:"hybrid.v1"`
	Namespace         string                 `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	WorkflowExecution *v1.WorkflowExecution  `protobuf:"bytes,2,opt,name=workflow_execution,json=workflowExecution,proto3" json:"workflow_execution,omitempty"`
	WorkflowType      *v1.WorkflowType       `protobuf:"bytes,3,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	InitiatedEventId  int64                  `protobuf:"varint,4,opt,name=initiated_event_id,json=initiatedEventId,proto3" json:"initiated_event_id,omitempty"`
	StartedEventId    int64                  `protobuf:"varint,5,opt,name=started_event_id,json=startedEventId,proto3" json:"started_event_id,omitempty"`
	RetryState        v11.RetryState         `protobuf:"varint,6,opt,name=retry_state,json=retryState,proto3,enum=temporal.api.enums.v1.RetryState" json:"retry_state,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ChildWorkflowExecutionFailureInfo) Reset() {
	*x = ChildWorkflowExecutionFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChildWorkflowExecutionFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChildWorkflowExecutionFailureInfo) ProtoMessage() {}

func (x *ChildWorkflowExecutionFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ChildWorkflowExecutionFailureInfo) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ChildWorkflowExecutionFailureInfo) GetWorkflowExecution() *v1.WorkflowExecution {
	if x != nil {
		return x.WorkflowExecution
	}
	return nil
}

func (x *ChildWorkflowExecutionFailureInfo) GetWorkflowType() *v1.WorkflowType {
	if x != nil {
		return x.WorkflowType
	}
	return nil
}

func (x *ChildWorkflowExecutionFailureInfo) GetInitiatedEventId() int64 {
	if x != nil {
		return x.InitiatedEventId
	}
	return 0
}

func (x *ChildWorkflowExecutionFailureInfo) GetStartedEventId() int64 {
	if x != nil {
		return x.StartedEventId
	}
	return 0
}

func (x *ChildWorkflowExecutionFailureInfo) GetRetryState() v11.RetryState {
	if x != nil {
		return x.RetryState
	}
	return v11.RetryState(0)
}

func (x *ChildWorkflowExecutionFailureInfo) SetNamespace(v string) {
	x.Namespace = v
}

func (x *ChildWorkflowExecutionFailureInfo) SetWorkflowExecution(v *v1.WorkflowExecution) {
	x.WorkflowExecution = v
}

func (x *ChildWorkflowExecutionFailureInfo) SetWorkflowType(v *v1.WorkflowType) {
	x.WorkflowType = v
}

func (x *ChildWorkflowExecutionFailureInfo) SetInitiatedEventId(v int64) {
	x.InitiatedEventId = v
}

func (x *ChildWorkflowExecutionFailureInfo) SetStartedEventId(v int64) {
	x.StartedEventId = v
}

func (x *ChildWorkflowExecutionFailureInfo) SetRetryState(v v11.RetryState) {
	x.RetryState = v
}

func (x *ChildWorkflowExecutionFailureInfo) HasWorkflowExecution() bool {
	if x == nil {
		return false
	}
	return x.WorkflowExecution != nil
}

func (x *ChildWorkflowExecutionFailureInfo) HasWorkflowType() bool {
	if x == nil {
		return false
	}
	return x.WorkflowType != nil
}

func (x *ChildWorkflowExecutionFailureInfo) ClearWorkflowExecution() {
	x.WorkflowExecution = nil
}

func (x *ChildWorkflowExecutionFailureInfo) ClearWorkflowType() {
	x.WorkflowType = nil
}

type ChildWorkflowExecutionFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Namespace         string
	WorkflowExecution *v1.WorkflowExecution
	WorkflowType      *v1.WorkflowType
	InitiatedEventId  int64
	StartedEventId    int64
	RetryState        v11.RetryState
}

func (b0 ChildWorkflowExecutionFailureInfo_builder) Build() *ChildWorkflowExecutionFailureInfo {
	m0 := &ChildWorkflowExecutionFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.Namespace = b.Namespace
	x.WorkflowExecution = b.WorkflowExecution
	x.WorkflowType = b.WorkflowType
	x.InitiatedEventId = b.InitiatedEventId
	x.StartedEventId = b.StartedEventId
	x.RetryState = b.RetryState
	return m0
}

type NexusOperationFailureInfo struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The NexusOperationScheduled event ID.
	ScheduledEventId int64 `protobuf:"varint,1,opt,name=scheduled_event_id,json=scheduledEventId,proto3" json:"scheduled_event_id,omitempty"`
	// Endpoint name.
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Service name.
	Service string `protobuf:"bytes,3,opt,name=service,proto3" json:"service,omitempty"`
	// Operation name.
	Operation string `protobuf:"bytes,4,opt,name=operation,proto3" json:"operation,omitempty"`
	// Operation ID - may be empty if the operation completed synchronously.
	//
	// Deprecated. Renamed to operation_token.
	//
	// Deprecated: Marked as deprecated in temporal/api/failure/v1/message.proto.
	OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
	// Operation token - may be empty if the operation completed synchronously.
	OperationToken string `protobuf:"bytes,6,opt,name=operation_token,json=operationToken,proto3" json:"operation_token,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NexusOperationFailureInfo) Reset() {
	*x = NexusOperationFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusOperationFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusOperationFailureInfo) ProtoMessage() {}

func (x *NexusOperationFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *NexusOperationFailureInfo) GetScheduledEventId() int64 {
	if x != nil {
		return x.ScheduledEventId
	}
	return 0
}

func (x *NexusOperationFailureInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetOperation() string {
	if x != nil {
		return x.Operation
	}
	return ""
}

// Deprecated: Marked as deprecated in temporal/api/failure/v1/message.proto.
func (x *NexusOperationFailureInfo) GetOperationId() string {
	if x != nil {
		return x.OperationId
	}
	return ""
}

func (x *NexusOperationFailureInfo) GetOperationToken() string {
	if x != nil {
		return x.OperationToken
	}
	return ""
}

func (x *NexusOperationFailureInfo) SetScheduledEventId(v int64) {
	x.ScheduledEventId = v
}

func (x *NexusOperationFailureInfo) SetEndpoint(v string) {
	x.Endpoint = v
}

func (x *NexusOperationFailureInfo) SetService(v string) {
	x.Service = v
}

func (x *NexusOperationFailureInfo) SetOperation(v string) {
	x.Operation = v
}

// Deprecated: Marked as deprecated in temporal/api/failure/v1/message.proto.
func (x *NexusOperationFailureInfo) SetOperationId(v string) {
	x.OperationId = v
}

func (x *NexusOperationFailureInfo) SetOperationToken(v string) {
	x.OperationToken = v
}

type NexusOperationFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The NexusOperationScheduled event ID.
	ScheduledEventId int64
	// Endpoint name.
	Endpoint string
	// Service name.
	Service string
	// Operation name.
	Operation string
	// Operation ID - may be empty if the operation completed synchronously.
	//
	// Deprecated. Renamed to operation_token.
	//
	// Deprecated: Marked as deprecated in temporal/api/failure/v1/message.proto.
	OperationId string
	// Operation token - may be empty if the operation completed synchronously.
	OperationToken string
}

func (b0 NexusOperationFailureInfo_builder) Build() *NexusOperationFailureInfo {
	m0 := &NexusOperationFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.ScheduledEventId = b.ScheduledEventId
	x.Endpoint = b.Endpoint
	x.Service = b.Service
	x.Operation = b.Operation
	x.OperationId = b.OperationId
	x.OperationToken = b.OperationToken
	return m0
}

type NexusHandlerFailureInfo struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The Nexus error type as defined in the spec:
	// https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
	RetryBehavior v11.NexusHandlerErrorRetryBehavior `protobuf:"varint,2,opt,name=retry_behavior,json=retryBehavior,proto3,enum=temporal.api.enums.v1.NexusHandlerErrorRetryBehavior" json:"retry_behavior,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NexusHandlerFailureInfo) Reset() {
	*x = NexusHandlerFailureInfo{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NexusHandlerFailureInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NexusHandlerFailureInfo) ProtoMessage() {}

func (x *NexusHandlerFailureInfo) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *NexusHandlerFailureInfo) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *NexusHandlerFailureInfo) GetRetryBehavior() v11.NexusHandlerErrorRetryBehavior {
	if x != nil {
		return x.RetryBehavior
	}
	return v11.NexusHandlerErrorRetryBehavior(0)
}

func (x *NexusHandlerFailureInfo) SetType(v string) {
	x.Type = v
}

func (x *NexusHandlerFailureInfo) SetRetryBehavior(v v11.NexusHandlerErrorRetryBehavior) {
	x.RetryBehavior = v
}

type NexusHandlerFailureInfo_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The Nexus error type as defined in the spec:
	// https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
	Type string
	// Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
	RetryBehavior v11.NexusHandlerErrorRetryBehavior
}

func (b0 NexusHandlerFailureInfo_builder) Build() *NexusHandlerFailureInfo {
	m0 := &NexusHandlerFailureInfo{}
	b, x := &b0, m0
	_, _ = b, x
	x.Type = b.Type
	x.RetryBehavior = b.RetryBehavior
	return m0
}

type Failure struct {
	state   protoimpl.MessageState `protogen:"hybrid.v1"`
	Message string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
	// In some SDKs this is used to rehydrate the stack trace into an exception object.
	Source     string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	StackTrace string `protobuf:"bytes,3,opt,name=stack_trace,json=stackTrace,proto3" json:"stack_trace,omitempty"`
	// Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
	// errors originating in user code which might contain sensitive information.
	// The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
	// message.
	//
	// SDK authors:
	// - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
	//   - Uses a JSON object to represent `{ message, stack_trace }`.
	//   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
	//   - Overwrites the original stack_trace with an empty string.
	//   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
	//     by the user-provided PayloadCodec
	//
	// - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
	// (-- api-linter: core::0203::optional=disabled --)
	EncodedAttributes *v1.Payload `protobuf:"bytes,20,opt,name=encoded_attributes,json=encodedAttributes,proto3" json:"encoded_attributes,omitempty"`
	Cause             *Failure    `protobuf:"bytes,4,opt,name=cause,proto3" json:"cause,omitempty"`
	// Types that are valid to be assigned to FailureInfo:
	//
	//	*Failure_ApplicationFailureInfo
	//	*Failure_TimeoutFailureInfo
	//	*Failure_CanceledFailureInfo
	//	*Failure_TerminatedFailureInfo
	//	*Failure_ServerFailureInfo
	//	*Failure_ResetWorkflowFailureInfo
	//	*Failure_ActivityFailureInfo
	//	*Failure_ChildWorkflowExecutionFailureInfo
	//	*Failure_NexusOperationExecutionFailureInfo
	//	*Failure_NexusHandlerFailureInfo
	FailureInfo   isFailure_FailureInfo `protobuf_oneof:"failure_info"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Failure) Reset() {
	*x = Failure{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Failure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Failure) ProtoMessage() {}

func (x *Failure) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Failure) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Failure) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Failure) GetStackTrace() string {
	if x != nil {
		return x.StackTrace
	}
	return ""
}

func (x *Failure) GetEncodedAttributes() *v1.Payload {
	if x != nil {
		return x.EncodedAttributes
	}
	return nil
}

func (x *Failure) GetCause() *Failure {
	if x != nil {
		return x.Cause
	}
	return nil
}

func (x *Failure) GetFailureInfo() isFailure_FailureInfo {
	if x != nil {
		return x.FailureInfo
	}
	return nil
}

func (x *Failure) GetApplicationFailureInfo() *ApplicationFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ApplicationFailureInfo); ok {
			return x.ApplicationFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetTimeoutFailureInfo() *TimeoutFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_TimeoutFailureInfo); ok {
			return x.TimeoutFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetCanceledFailureInfo() *CanceledFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_CanceledFailureInfo); ok {
			return x.CanceledFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetTerminatedFailureInfo() *TerminatedFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_TerminatedFailureInfo); ok {
			return x.TerminatedFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetServerFailureInfo() *ServerFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ServerFailureInfo); ok {
			return x.ServerFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetResetWorkflowFailureInfo() *ResetWorkflowFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ResetWorkflowFailureInfo); ok {
			return x.ResetWorkflowFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetActivityFailureInfo() *ActivityFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ActivityFailureInfo); ok {
			return x.ActivityFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetChildWorkflowExecutionFailureInfo() *ChildWorkflowExecutionFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_ChildWorkflowExecutionFailureInfo); ok {
			return x.ChildWorkflowExecutionFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetNexusOperationExecutionFailureInfo() *NexusOperationFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_NexusOperationExecutionFailureInfo); ok {
			return x.NexusOperationExecutionFailureInfo
		}
	}
	return nil
}

func (x *Failure) GetNexusHandlerFailureInfo() *NexusHandlerFailureInfo {
	if x != nil {
		if x, ok := x.FailureInfo.(*Failure_NexusHandlerFailureInfo); ok {
			return x.NexusHandlerFailureInfo
		}
	}
	return nil
}

func (x *Failure) SetMessage(v string) {
	x.Message = v
}

func (x *Failure) SetSource(v string) {
	x.Source = v
}

func (x *Failure) SetStackTrace(v string) {
	x.StackTrace = v
}

func (x *Failure) SetEncodedAttributes(v *v1.Payload) {
	x.EncodedAttributes = v
}

func (x *Failure) SetCause(v *Failure) {
	x.Cause = v
}

func (x *Failure) SetApplicationFailureInfo(v *ApplicationFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_ApplicationFailureInfo{v}
}

func (x *Failure) SetTimeoutFailureInfo(v *TimeoutFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_TimeoutFailureInfo{v}
}

func (x *Failure) SetCanceledFailureInfo(v *CanceledFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_CanceledFailureInfo{v}
}

func (x *Failure) SetTerminatedFailureInfo(v *TerminatedFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_TerminatedFailureInfo{v}
}

func (x *Failure) SetServerFailureInfo(v *ServerFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_ServerFailureInfo{v}
}

func (x *Failure) SetResetWorkflowFailureInfo(v *ResetWorkflowFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_ResetWorkflowFailureInfo{v}
}

func (x *Failure) SetActivityFailureInfo(v *ActivityFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_ActivityFailureInfo{v}
}

func (x *Failure) SetChildWorkflowExecutionFailureInfo(v *ChildWorkflowExecutionFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_ChildWorkflowExecutionFailureInfo{v}
}

func (x *Failure) SetNexusOperationExecutionFailureInfo(v *NexusOperationFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_NexusOperationExecutionFailureInfo{v}
}

func (x *Failure) SetNexusHandlerFailureInfo(v *NexusHandlerFailureInfo) {
	if v == nil {
		x.FailureInfo = nil
		return
	}
	x.FailureInfo = &Failure_NexusHandlerFailureInfo{v}
}

func (x *Failure) HasEncodedAttributes() bool {
	if x == nil {
		return false
	}
	return x.EncodedAttributes != nil
}

func (x *Failure) HasCause() bool {
	if x == nil {
		return false
	}
	return x.Cause != nil
}

func (x *Failure) HasFailureInfo() bool {
	if x == nil {
		return false
	}
	return x.FailureInfo != nil
}

func (x *Failure) HasApplicationFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_ApplicationFailureInfo)
	return ok
}

func (x *Failure) HasTimeoutFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_TimeoutFailureInfo)
	return ok
}

func (x *Failure) HasCanceledFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_CanceledFailureInfo)
	return ok
}

func (x *Failure) HasTerminatedFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_TerminatedFailureInfo)
	return ok
}

func (x *Failure) HasServerFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_ServerFailureInfo)
	return ok
}

func (x *Failure) HasResetWorkflowFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_ResetWorkflowFailureInfo)
	return ok
}

func (x *Failure) HasActivityFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_ActivityFailureInfo)
	return ok
}

func (x *Failure) HasChildWorkflowExecutionFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_ChildWorkflowExecutionFailureInfo)
	return ok
}

func (x *Failure) HasNexusOperationExecutionFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_NexusOperationExecutionFailureInfo)
	return ok
}

func (x *Failure) HasNexusHandlerFailureInfo() bool {
	if x == nil {
		return false
	}
	_, ok := x.FailureInfo.(*Failure_NexusHandlerFailureInfo)
	return ok
}

func (x *Failure) ClearEncodedAttributes() {
	x.EncodedAttributes = nil
}

func (x *Failure) ClearCause() {
	x.Cause = nil
}

func (x *Failure) ClearFailureInfo() {
	x.FailureInfo = nil
}

func (x *Failure) ClearApplicationFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_ApplicationFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearTimeoutFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_TimeoutFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearCanceledFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_CanceledFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearTerminatedFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_TerminatedFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearServerFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_ServerFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearResetWorkflowFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_ResetWorkflowFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearActivityFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_ActivityFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearChildWorkflowExecutionFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_ChildWorkflowExecutionFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearNexusOperationExecutionFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_NexusOperationExecutionFailureInfo); ok {
		x.FailureInfo = nil
	}
}

func (x *Failure) ClearNexusHandlerFailureInfo() {
	if _, ok := x.FailureInfo.(*Failure_NexusHandlerFailureInfo); ok {
		x.FailureInfo = nil
	}
}

const Failure_FailureInfo_not_set_case case_Failure_FailureInfo = 0
const Failure_ApplicationFailureInfo_case case_Failure_FailureInfo = 5
const Failure_TimeoutFailureInfo_case case_Failure_FailureInfo = 6
const Failure_CanceledFailureInfo_case case_Failure_FailureInfo = 7
const Failure_TerminatedFailureInfo_case case_Failure_FailureInfo = 8
const Failure_ServerFailureInfo_case case_Failure_FailureInfo = 9
const Failure_ResetWorkflowFailureInfo_case case_Failure_FailureInfo = 10
const Failure_ActivityFailureInfo_case case_Failure_FailureInfo = 11
const Failure_ChildWorkflowExecutionFailureInfo_case case_Failure_FailureInfo = 12
const Failure_NexusOperationExecutionFailureInfo_case case_Failure_FailureInfo = 13
const Failure_NexusHandlerFailureInfo_case case_Failure_FailureInfo = 14

func (x *Failure) WhichFailureInfo() case_Failure_FailureInfo {
	if x == nil {
		return Failure_FailureInfo_not_set_case
	}
	switch x.FailureInfo.(type) {
	case *Failure_ApplicationFailureInfo:
		return Failure_ApplicationFailureInfo_case
	case *Failure_TimeoutFailureInfo:
		return Failure_TimeoutFailureInfo_case
	case *Failure_CanceledFailureInfo:
		return Failure_CanceledFailureInfo_case
	case *Failure_TerminatedFailureInfo:
		return Failure_TerminatedFailureInfo_case
	case *Failure_ServerFailureInfo:
		return Failure_ServerFailureInfo_case
	case *Failure_ResetWorkflowFailureInfo:
		return Failure_ResetWorkflowFailureInfo_case
	case *Failure_ActivityFailureInfo:
		return Failure_ActivityFailureInfo_case
	case *Failure_ChildWorkflowExecutionFailureInfo:
		return Failure_ChildWorkflowExecutionFailureInfo_case
	case *Failure_NexusOperationExecutionFailureInfo:
		return Failure_NexusOperationExecutionFailureInfo_case
	case *Failure_NexusHandlerFailureInfo:
		return Failure_NexusHandlerFailureInfo_case
	default:
		return Failure_FailureInfo_not_set_case
	}
}

type Failure_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	Message string
	// The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
	// In some SDKs this is used to rehydrate the stack trace into an exception object.
	Source     string
	StackTrace string
	// Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
	// errors originating in user code which might contain sensitive information.
	// The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
	// message.
	//
	// SDK authors:
	// - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
	//   - Uses a JSON object to represent `{ message, stack_trace }`.
	//   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
	//   - Overwrites the original stack_trace with an empty string.
	//   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
	//     by the user-provided PayloadCodec
	//
	// - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
	// (-- api-linter: core::0203::optional=disabled --)
	EncodedAttributes *v1.Payload
	Cause             *Failure
	// Fields of oneof FailureInfo:
	ApplicationFailureInfo             *ApplicationFailureInfo
	TimeoutFailureInfo                 *TimeoutFailureInfo
	CanceledFailureInfo                *CanceledFailureInfo
	TerminatedFailureInfo              *TerminatedFailureInfo
	ServerFailureInfo                  *ServerFailureInfo
	ResetWorkflowFailureInfo           *ResetWorkflowFailureInfo
	ActivityFailureInfo                *ActivityFailureInfo
	ChildWorkflowExecutionFailureInfo  *ChildWorkflowExecutionFailureInfo
	NexusOperationExecutionFailureInfo *NexusOperationFailureInfo
	NexusHandlerFailureInfo            *NexusHandlerFailureInfo
	// -- end of FailureInfo
}

func (b0 Failure_builder) Build() *Failure {
	m0 := &Failure{}
	b, x := &b0, m0
	_, _ = b, x
	x.Message = b.Message
	x.Source = b.Source
	x.StackTrace = b.StackTrace
	x.EncodedAttributes = b.EncodedAttributes
	x.Cause = b.Cause
	if b.ApplicationFailureInfo != nil {
		x.FailureInfo = &Failure_ApplicationFailureInfo{b.ApplicationFailureInfo}
	}
	if b.TimeoutFailureInfo != nil {
		x.FailureInfo = &Failure_TimeoutFailureInfo{b.TimeoutFailureInfo}
	}
	if b.CanceledFailureInfo != nil {
		x.FailureInfo = &Failure_CanceledFailureInfo{b.CanceledFailureInfo}
	}
	if b.TerminatedFailureInfo != nil {
		x.FailureInfo = &Failure_TerminatedFailureInfo{b.TerminatedFailureInfo}
	}
	if b.ServerFailureInfo != nil {
		x.FailureInfo = &Failure_ServerFailureInfo{b.ServerFailureInfo}
	}
	if b.ResetWorkflowFailureInfo != nil {
		x.FailureInfo = &Failure_ResetWorkflowFailureInfo{b.ResetWorkflowFailureInfo}
	}
	if b.ActivityFailureInfo != nil {
		x.FailureInfo = &Failure_ActivityFailureInfo{b.ActivityFailureInfo}
	}
	if b.ChildWorkflowExecutionFailureInfo != nil {
		x.FailureInfo = &Failure_ChildWorkflowExecutionFailureInfo{b.ChildWorkflowExecutionFailureInfo}
	}
	if b.NexusOperationExecutionFailureInfo != nil {
		x.FailureInfo = &Failure_NexusOperationExecutionFailureInfo{b.NexusOperationExecutionFailureInfo}
	}
	if b.NexusHandlerFailureInfo != nil {
		x.FailureInfo = &Failure_NexusHandlerFailureInfo{b.NexusHandlerFailureInfo}
	}
	return m0
}

type case_Failure_FailureInfo protoreflect.FieldNumber

func (x case_Failure_FailureInfo) String() string {
	switch x {
	case Failure_FailureInfo_not_set_case:
		return "FailureFailureInfoNotSetCase"
	case Failure_ApplicationFailureInfo_case:
		return "FailureApplicationFailureInfoCase"
	case Failure_TimeoutFailureInfo_case:
		return "FailureTimeoutFailureInfoCase"
	case Failure_CanceledFailureInfo_case:
		return "FailureCanceledFailureInfoCase"
	case Failure_TerminatedFailureInfo_case:
		return "FailureTerminatedFailureInfoCase"
	case Failure_ServerFailureInfo_case:
		return "FailureServerFailureInfoCase"
	case Failure_ResetWorkflowFailureInfo_case:
		return "FailureResetWorkflowFailureInfoCase"
	case Failure_ActivityFailureInfo_case:
		return "FailureActivityFailureInfoCase"
	case Failure_ChildWorkflowExecutionFailureInfo_case:
		return "FailureChildWorkflowExecutionFailureInfoCase"
	case Failure_NexusOperationExecutionFailureInfo_case:
		return "FailureNexusOperationExecutionFailureInfoCase"
	case Failure_NexusHandlerFailureInfo_case:
		return "FailureNexusHandlerFailureInfoCase"
	default:
		return strconv.Itoa(int(x))
	}

}

type isFailure_FailureInfo interface {
	isFailure_FailureInfo()
}

type Failure_ApplicationFailureInfo struct {
	ApplicationFailureInfo *ApplicationFailureInfo `protobuf:"bytes,5,opt,name=application_failure_info,json=applicationFailureInfo,proto3,oneof"`
}

type Failure_TimeoutFailureInfo struct {
	TimeoutFailureInfo *TimeoutFailureInfo `protobuf:"bytes,6,opt,name=timeout_failure_info,json=timeoutFailureInfo,proto3,oneof"`
}

type Failure_CanceledFailureInfo struct {
	CanceledFailureInfo *CanceledFailureInfo `protobuf:"bytes,7,opt,name=canceled_failure_info,json=canceledFailureInfo,proto3,oneof"`
}

type Failure_TerminatedFailureInfo struct {
	TerminatedFailureInfo *TerminatedFailureInfo `protobuf:"bytes,8,opt,name=terminated_failure_info,json=terminatedFailureInfo,proto3,oneof"`
}

type Failure_ServerFailureInfo struct {
	ServerFailureInfo *ServerFailureInfo `protobuf:"bytes,9,opt,name=server_failure_info,json=serverFailureInfo,proto3,oneof"`
}

type Failure_ResetWorkflowFailureInfo struct {
	ResetWorkflowFailureInfo *ResetWorkflowFailureInfo `protobuf:"bytes,10,opt,name=reset_workflow_failure_info,json=resetWorkflowFailureInfo,proto3,oneof"`
}

type Failure_ActivityFailureInfo struct {
	ActivityFailureInfo *ActivityFailureInfo `protobuf:"bytes,11,opt,name=activity_failure_info,json=activityFailureInfo,proto3,oneof"`
}

type Failure_ChildWorkflowExecutionFailureInfo struct {
	ChildWorkflowExecutionFailureInfo *ChildWorkflowExecutionFailureInfo `protobuf:"bytes,12,opt,name=child_workflow_execution_failure_info,json=childWorkflowExecutionFailureInfo,proto3,oneof"`
}

type Failure_NexusOperationExecutionFailureInfo struct {
	NexusOperationExecutionFailureInfo *NexusOperationFailureInfo `protobuf:"bytes,13,opt,name=nexus_operation_execution_failure_info,json=nexusOperationExecutionFailureInfo,proto3,oneof"`
}

type Failure_NexusHandlerFailureInfo struct {
	NexusHandlerFailureInfo *NexusHandlerFailureInfo `protobuf:"bytes,14,opt,name=nexus_handler_failure_info,json=nexusHandlerFailureInfo,proto3,oneof"`
}

func (*Failure_ApplicationFailureInfo) isFailure_FailureInfo() {}

func (*Failure_TimeoutFailureInfo) isFailure_FailureInfo() {}

func (*Failure_CanceledFailureInfo) isFailure_FailureInfo() {}

func (*Failure_TerminatedFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ServerFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ResetWorkflowFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ActivityFailureInfo) isFailure_FailureInfo() {}

func (*Failure_ChildWorkflowExecutionFailureInfo) isFailure_FailureInfo() {}

func (*Failure_NexusOperationExecutionFailureInfo) isFailure_FailureInfo() {}

func (*Failure_NexusHandlerFailureInfo) isFailure_FailureInfo() {}

type MultiOperationExecutionAborted struct {
	state         protoimpl.MessageState `protogen:"hybrid.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiOperationExecutionAborted) Reset() {
	*x = MultiOperationExecutionAborted{}
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiOperationExecutionAborted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiOperationExecutionAborted) ProtoMessage() {}

func (x *MultiOperationExecutionAborted) ProtoReflect() protoreflect.Message {
	mi := &file_temporal_api_failure_v1_message_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

type MultiOperationExecutionAborted_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

}

func (b0 MultiOperationExecutionAborted_builder) Build() *MultiOperationExecutionAborted {
	m0 := &MultiOperationExecutionAborted{}
	b, x := &b0, m0
	_, _ = b, x
	return m0
}

var File_temporal_api_failure_v1_message_proto protoreflect.FileDescriptor

const file_temporal_api_failure_v1_message_proto_rawDesc = "" +
	"\n" +
	"%temporal/api/failure/v1/message.proto\x12\x17temporal.api.failure.v1\x1a$temporal/api/common/v1/message.proto\x1a$temporal/api/enums/v1/workflow.proto\x1a!temporal/api/enums/v1/nexus.proto\x1a\"temporal/api/enums/v1/common.proto\x1a\x1egoogle/protobuf/duration.proto\"\x9f\x02\n" +
	"\x16ApplicationFailureInfo\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12#\n" +
	"\rnon_retryable\x18\x02 \x01(\bR\fnonRetryable\x12:\n" +
	"\adetails\x18\x03 \x01(\v2 .temporal.api.common.v1.PayloadsR\adetails\x12C\n" +
	"\x10next_retry_delay\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x0enextRetryDelay\x12K\n" +
	"\bcategory\x18\x05 \x01(\x0e2/.temporal.api.enums.v1.ApplicationErrorCategoryR\bcategory\"\xb3\x01\n" +
	"\x12TimeoutFailureInfo\x12E\n" +
	"\ftimeout_type\x18\x01 \x01(\x0e2\".temporal.api.enums.v1.TimeoutTypeR\vtimeoutType\x12V\n" +
	"\x16last_heartbeat_details\x18\x02 \x01(\v2 .temporal.api.common.v1.PayloadsR\x14lastHeartbeatDetails\"Q\n" +
	"\x13CanceledFailureInfo\x12:\n" +
	"\adetails\x18\x01 \x01(\v2 .temporal.api.common.v1.PayloadsR\adetails\"\x17\n" +
	"\x15TerminatedFailureInfo\"8\n" +
	"\x11ServerFailureInfo\x12#\n" +
	"\rnon_retryable\x18\x01 \x01(\bR\fnonRetryable\"r\n" +
	"\x18ResetWorkflowFailureInfo\x12V\n" +
	"\x16last_heartbeat_details\x18\x01 \x01(\v2 .temporal.api.common.v1.PayloadsR\x14lastHeartbeatDetails\"\xb9\x02\n" +
	"\x13ActivityFailureInfo\x12,\n" +
	"\x12scheduled_event_id\x18\x01 \x01(\x03R\x10scheduledEventId\x12(\n" +
	"\x10started_event_id\x18\x02 \x01(\x03R\x0estartedEventId\x12\x1a\n" +
	"\bidentity\x18\x03 \x01(\tR\bidentity\x12I\n" +
	"\ractivity_type\x18\x04 \x01(\v2$.temporal.api.common.v1.ActivityTypeR\factivityType\x12\x1f\n" +
	"\vactivity_id\x18\x05 \x01(\tR\n" +
	"activityId\x12B\n" +
	"\vretry_state\x18\x06 \x01(\x0e2!.temporal.api.enums.v1.RetryStateR\n" +
	"retryState\"\x82\x03\n" +
	"!ChildWorkflowExecutionFailureInfo\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12X\n" +
	"\x12workflow_execution\x18\x02 \x01(\v2).temporal.api.common.v1.WorkflowExecutionR\x11workflowExecution\x12I\n" +
	"\rworkflow_type\x18\x03 \x01(\v2$.temporal.api.common.v1.WorkflowTypeR\fworkflowType\x12,\n" +
	"\x12initiated_event_id\x18\x04 \x01(\x03R\x10initiatedEventId\x12(\n" +
	"\x10started_event_id\x18\x05 \x01(\x03R\x0estartedEventId\x12B\n" +
	"\vretry_state\x18\x06 \x01(\x0e2!.temporal.api.enums.v1.RetryStateR\n" +
	"retryState\"\xed\x01\n" +
	"\x19NexusOperationFailureInfo\x12,\n" +
	"\x12scheduled_event_id\x18\x01 \x01(\x03R\x10scheduledEventId\x12\x1a\n" +
	"\bendpoint\x18\x02 \x01(\tR\bendpoint\x12\x18\n" +
	"\aservice\x18\x03 \x01(\tR\aservice\x12\x1c\n" +
	"\toperation\x18\x04 \x01(\tR\toperation\x12%\n" +
	"\foperation_id\x18\x05 \x01(\tB\x02\x18\x01R\voperationId\x12'\n" +
	"\x0foperation_token\x18\x06 \x01(\tR\x0eoperationToken\"\x8b\x01\n" +
	"\x17NexusHandlerFailureInfo\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\\\n" +
	"\x0eretry_behavior\x18\x02 \x01(\x0e25.temporal.api.enums.v1.NexusHandlerErrorRetryBehaviorR\rretryBehavior\"\xd3\n" +
	"\n" +
	"\aFailure\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12\x1f\n" +
	"\vstack_trace\x18\x03 \x01(\tR\n" +
	"stackTrace\x12N\n" +
	"\x12encoded_attributes\x18\x14 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x11encodedAttributes\x126\n" +
	"\x05cause\x18\x04 \x01(\v2 .temporal.api.failure.v1.FailureR\x05cause\x12k\n" +
	"\x18application_failure_info\x18\x05 \x01(\v2/.temporal.api.failure.v1.ApplicationFailureInfoH\x00R\x16applicationFailureInfo\x12_\n" +
	"\x14timeout_failure_info\x18\x06 \x01(\v2+.temporal.api.failure.v1.TimeoutFailureInfoH\x00R\x12timeoutFailureInfo\x12b\n" +
	"\x15canceled_failure_info\x18\a \x01(\v2,.temporal.api.failure.v1.CanceledFailureInfoH\x00R\x13canceledFailureInfo\x12h\n" +
	"\x17terminated_failure_info\x18\b \x01(\v2..temporal.api.failure.v1.TerminatedFailureInfoH\x00R\x15terminatedFailureInfo\x12\\\n" +
	"\x13server_failure_info\x18\t \x01(\v2*.temporal.api.failure.v1.ServerFailureInfoH\x00R\x11serverFailureInfo\x12r\n" +
	"\x1breset_workflow_failure_info\x18\n" +
	" \x01(\v21.temporal.api.failure.v1.ResetWorkflowFailureInfoH\x00R\x18resetWorkflowFailureInfo\x12b\n" +
	"\x15activity_failure_info\x18\v \x01(\v2,.temporal.api.failure.v1.ActivityFailureInfoH\x00R\x13activityFailureInfo\x12\x8e\x01\n" +
	"%child_workflow_execution_failure_info\x18\f \x01(\v2:.temporal.api.failure.v1.ChildWorkflowExecutionFailureInfoH\x00R!childWorkflowExecutionFailureInfo\x12\x88\x01\n" +
	"&nexus_operation_execution_failure_info\x18\r \x01(\v22.temporal.api.failure.v1.NexusOperationFailureInfoH\x00R\"nexusOperationExecutionFailureInfo\x12o\n" +
	"\x1anexus_handler_failure_info\x18\x0e \x01(\v20.temporal.api.failure.v1.NexusHandlerFailureInfoH\x00R\x17nexusHandlerFailureInfoB\x0e\n" +
	"\ffailure_info\" \n" +
	"\x1eMultiOperationExecutionAbortedB\x8e\x01\n" +
	"\x1aio.temporal.api.failure.v1B\fMessageProtoP\x01Z%go.temporal.io/api/failure/v1;failure\xaa\x02\x19Temporalio.Api.Failure.V1\xea\x02\x1cTemporalio::Api::Failure::V1b\x06proto3"

var file_temporal_api_failure_v1_message_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_temporal_api_failure_v1_message_proto_goTypes = []any{
	(*ApplicationFailureInfo)(nil),            // 0: temporal.api.failure.v1.ApplicationFailureInfo
	(*TimeoutFailureInfo)(nil),                // 1: temporal.api.failure.v1.TimeoutFailureInfo
	(*CanceledFailureInfo)(nil),               // 2: temporal.api.failure.v1.CanceledFailureInfo
	(*TerminatedFailureInfo)(nil),             // 3: temporal.api.failure.v1.TerminatedFailureInfo
	(*ServerFailureInfo)(nil),                 // 4: temporal.api.failure.v1.ServerFailureInfo
	(*ResetWorkflowFailureInfo)(nil),          // 5: temporal.api.failure.v1.ResetWorkflowFailureInfo
	(*ActivityFailureInfo)(nil),               // 6: temporal.api.failure.v1.ActivityFailureInfo
	(*ChildWorkflowExecutionFailureInfo)(nil), // 7: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo
	(*NexusOperationFailureInfo)(nil),         // 8: temporal.api.failure.v1.NexusOperationFailureInfo
	(*NexusHandlerFailureInfo)(nil),           // 9: temporal.api.failure.v1.NexusHandlerFailureInfo
	(*Failure)(nil),                           // 10: temporal.api.failure.v1.Failure
	(*MultiOperationExecutionAborted)(nil),    // 11: temporal.api.failure.v1.MultiOperationExecutionAborted
	(*v1.Payloads)(nil),                       // 12: temporal.api.common.v1.Payloads
	(*durationpb.Duration)(nil),               // 13: google.protobuf.Duration
	(v11.ApplicationErrorCategory)(0),         // 14: temporal.api.enums.v1.ApplicationErrorCategory
	(v11.TimeoutType)(0),                      // 15: temporal.api.enums.v1.TimeoutType
	(*v1.ActivityType)(nil),                   // 16: temporal.api.common.v1.ActivityType
	(v11.RetryState)(0),                       // 17: temporal.api.enums.v1.RetryState
	(*v1.WorkflowExecution)(nil),              // 18: temporal.api.common.v1.WorkflowExecution
	(*v1.WorkflowType)(nil),                   // 19: temporal.api.common.v1.WorkflowType
	(v11.NexusHandlerErrorRetryBehavior)(0),   // 20: temporal.api.enums.v1.NexusHandlerErrorRetryBehavior
	(*v1.Payload)(nil),                        // 21: temporal.api.common.v1.Payload
}
var file_temporal_api_failure_v1_message_proto_depIdxs = []int32{
	12, // 0: temporal.api.failure.v1.ApplicationFailureInfo.details:type_name -> temporal.api.common.v1.Payloads
	13, // 1: temporal.api.failure.v1.ApplicationFailureInfo.next_retry_delay:type_name -> google.protobuf.Duration
	14, // 2: temporal.api.failure.v1.ApplicationFailureInfo.category:type_name -> temporal.api.enums.v1.ApplicationErrorCategory
	15, // 3: temporal.api.failure.v1.TimeoutFailureInfo.timeout_type:type_name -> temporal.api.enums.v1.TimeoutType
	12, // 4: temporal.api.failure.v1.TimeoutFailureInfo.last_heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	12, // 5: temporal.api.failure.v1.CanceledFailureInfo.details:type_name -> temporal.api.common.v1.Payloads
	12, // 6: temporal.api.failure.v1.ResetWorkflowFailureInfo.last_heartbeat_details:type_name -> temporal.api.common.v1.Payloads
	16, // 7: temporal.api.failure.v1.ActivityFailureInfo.activity_type:type_name -> temporal.api.common.v1.ActivityType
	17, // 8: temporal.api.failure.v1.ActivityFailureInfo.retry_state:type_name -> temporal.api.enums.v1.RetryState
	18, // 9: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.workflow_execution:type_name -> temporal.api.common.v1.WorkflowExecution
	19, // 10: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.workflow_type:type_name -> temporal.api.common.v1.WorkflowType
	17, // 11: temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo.retry_state:type_name -> temporal.api.enums.v1.RetryState
	20, // 12: temporal.api.failure.v1.NexusHandlerFailureInfo.retry_behavior:type_name -> temporal.api.enums.v1.NexusHandlerErrorRetryBehavior
	21, // 13: temporal.api.failure.v1.Failure.encoded_attributes:type_name -> temporal.api.common.v1.Payload
	10, // 14: temporal.api.failure.v1.Failure.cause:type_name -> temporal.api.failure.v1.Failure
	0,  // 15: temporal.api.failure.v1.Failure.application_failure_info:type_name -> temporal.api.failure.v1.ApplicationFailureInfo
	1,  // 16: temporal.api.failure.v1.Failure.timeout_failure_info:type_name -> temporal.api.failure.v1.TimeoutFailureInfo
	2,  // 17: temporal.api.failure.v1.Failure.canceled_failure_info:type_name -> temporal.api.failure.v1.CanceledFailureInfo
	3,  // 18: temporal.api.failure.v1.Failure.terminated_failure_info:type_name -> temporal.api.failure.v1.TerminatedFailureInfo
	4,  // 19: temporal.api.failure.v1.Failure.server_failure_info:type_name -> temporal.api.failure.v1.ServerFailureInfo
	5,  // 20: temporal.api.failure.v1.Failure.reset_workflow_failure_info:type_name -> temporal.api.failure.v1.ResetWorkflowFailureInfo
	6,  // 21: temporal.api.failure.v1.Failure.activity_failure_info:type_name -> temporal.api.failure.v1.ActivityFailureInfo
	7,  // 22: temporal.api.failure.v1.Failure.child_workflow_execution_failure_info:type_name -> temporal.api.failure.v1.ChildWorkflowExecutionFailureInfo
	8,  // 23: temporal.api.failure.v1.Failure.nexus_operation_execution_failure_info:type_name -> temporal.api.failure.v1.NexusOperationFailureInfo
	9,  // 24: temporal.api.failure.v1.Failure.nexus_handler_failure_info:type_name -> temporal.api.failure.v1.NexusHandlerFailureInfo
	25, // [25:25] is the sub-list for method output_type
	25, // [25:25] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_temporal_api_failure_v1_message_proto_init() }
func file_temporal_api_failure_v1_message_proto_init() {
	if File_temporal_api_failure_v1_message_proto != nil {
		return
	}
	file_temporal_api_failure_v1_message_proto_msgTypes[10].OneofWrappers = []any{
		(*Failure_ApplicationFailureInfo)(nil),
		(*Failure_TimeoutFailureInfo)(nil),
		(*Failure_CanceledFailureInfo)(nil),
		(*Failure_TerminatedFailureInfo)(nil),
		(*Failure_ServerFailureInfo)(nil),
		(*Failure_ResetWorkflowFailureInfo)(nil),
		(*Failure_ActivityFailureInfo)(nil),
		(*Failure_ChildWorkflowExecutionFailureInfo)(nil),
		(*Failure_NexusOperationExecutionFailureInfo)(nil),
		(*Failure_NexusHandlerFailureInfo)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_temporal_api_failure_v1_message_proto_rawDesc), len(file_temporal_api_failure_v1_message_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_temporal_api_failure_v1_message_proto_goTypes,
		DependencyIndexes: file_temporal_api_failure_v1_message_proto_depIdxs,
		MessageInfos:      file_temporal_api_failure_v1_message_proto_msgTypes,
	}.Build()
	File_temporal_api_failure_v1_message_proto = out.File
	file_temporal_api_failure_v1_message_proto_goTypes = nil
	file_temporal_api_failure_v1_message_proto_depIdxs = nil
}
